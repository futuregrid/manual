<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vampir &mdash; Cloud Computing Book 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/2.3.2/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap-responsive.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-2.3.2/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Cloud Computing Book 0.1 documentation" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="brand" href="index.html">Contents</a>
        <span class="navbar-text pull-left"><b>0.1</b></span>

        <div class="nav-collapse">
          <ul class="nav">
            <li class="divider-vertical"></li>
            
              <li class="dropdown globaltoc-container">
  <a href="index.html"
     class="dropdown-toggle"
     data-toggle="dropdown">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
    ><ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">1. Preface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="preface.html#citation-for-publications">1.1. Citation for Publications</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#acknowledgement">1.2. Acknowledgement</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#sponsors">1.3. Sponsors</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#about-this-manual">1.4. About this Manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="preface.html#conventions">1.5. Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">2. Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#executive-summary">2.1. Executive Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#project-and-account-application">2.2. Project and Account Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#services">2.3. Services</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#hardware">2.4. Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#support">2.5. Support</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="account.html">1. Project and Account Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="account.html#terminology">1.1. Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#quickstart">1.2. Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#projects-and-accounts-for-xsede-users">1.3. Projects and Accounts for XSEDE users</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#project-management">1.4. Project Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#upload-a-ssh-public-key">1.5. Upload a SSH Public Key</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#upload-an-openid">1.6. Upload an OpenId</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#accessing-futuregrid-resources">1.7. Accessing FutureGrid Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#manage-a-class-on-futuregrid">1.8. Manage a Class on FutureGrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="account.html#mini-faq">1.9. Mini FAQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="security.html">2. Using SSH keys</a><ul>
<li class="toctree-l2"><a class="reference internal" href="security.html#using-ssh-from-windows">2.1. Using SSH from Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#generate-a-ssh-key">2.2. Generate a SSH key</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#add-or-replace-passphrase-for-an-already-generated-key">2.3. Add or Replace Passphrase for an Already Generated Key</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#upload-the-key-to-the-futuregrid-portal">2.4. Upload the key to the FutureGrid Portal</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#testing-your-ssh-key">2.5. Testing your ssh key</a></li>
<li class="toctree-l2"><a class="reference internal" href="security.html#testing-your-ssh-key-for-hotel">2.6. Testing your ssh key for Hotel</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="status.html">1. Status</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="hardware.html">1. Hardware</a><ul>
<li class="toctree-l2"><a class="reference internal" href="hardware.html#compute-resources">1.1. Compute Resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="hardware.html#networks">1.2. Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="hardware.html#network-impairments-device-nid">1.3. Network Impairments Device (NID)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="hpc.html">2. HPC Services</a><ul>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#login-nodes">2.1. Login Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#message-passing-interface-mpi">2.2. Message Passing Interface (MPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#job-management">2.3. Job Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="hpc.html#xray-hpc-services">2.4. Xray HPC Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="scalemp.html">3. ScaleMP vSMP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="scalemp.html#accessing-scalemp">3.1. Accessing ScaleMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="scalemp.html#submitting-a-job">3.2. Submitting a job</a></li>
<li class="toctree-l2"><a class="reference internal" href="scalemp.html#developing-a-job-script">3.3. Developing a job script</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="iaas.html">1. IaaS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#nimbus-clouds">1.1. Nimbus Clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#openstack-clouds">1.2. OpenStack Clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#eucalyptus-clouds">1.3. Eucalyptus Clouds</a></li>
<li class="toctree-l2"><a class="reference internal" href="iaas.html#virtual-appliances-for-training-and-education">1.4. Virtual Appliances for Training and Education</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="openstack.html">2. OpenStack Essex with euca2ools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#prerequisits">2.1. Prerequisits</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#log-into-india">2.2. Log into India</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#system-variable-user">2.3. System Variable $USER</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#account-and-credentials">2.4. Account and Credentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#euca2ools-ec2-client-tools">2.5. Euca2ools (EC2 client tools)</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#testing-your-setup">2.6. Testing Your Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#list-of-common-images">2.7. List of Common Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#vm-types">2.8. VM Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#key-management">2.9. Key Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#image-instantiation">2.10. Image Instantiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#rename-server-names">2.11. Rename Server Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#monitoring-instances">2.12. Monitoring Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#log-into-your-vm">2.13. Log into your VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#nova-volumes-not-available">2.14. Nova Volumes (Not available)</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#volume-snapshots">2.15. Volume Snapshots</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#image-registration">2.16. Image Registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#delete-your-images">2.17. Delete your images</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#terminate-your-vms">2.18. Terminate your VMs</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#limitations">2.19. Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#troubleshooting">2.20. Troubleshooting</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack.html#compatibility-between-nova-and-euca2ools-commands">2.21. Compatibility between nova and euca2ools commands</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="openstack-grizzly.html">3. OpenStack Grizzly</a><ul>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#use-block-storage">3.1. Use Block Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#set-up-external-access-to-your-instance">3.2. Set up external access to your instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#make-a-snapshot-of-an-instance">3.3. Make a snapshot of an instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#automate-some-initial-configuration">3.4. Automate some initial configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#get-the-latest-version-of-ubuntu-cloud-image-and-upload-it-to-the-openstack">3.5. Get the latest version of Ubuntu Cloud Image and upload it to the OpenStack</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#delete-your-instance">3.6. Delete your instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#how-to-change-your-password">3.7. How to change your password</a></li>
<li class="toctree-l2"><a class="reference internal" href="openstack-grizzly.html#things-to-do-when-you-need-euca2ools-or-ec2-interfaces">3.8. Things to do when you need Euca2ools or EC2 interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="eucalyptus.html">5. Eucalyptus</a><ul>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#account-creation">5.1. Account Creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#resources-overview">5.2. Resources Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#testing-your-setup">5.3. Testing Your Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#image-deployment">5.4. Image Deployment</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#logging-into-the-vm">5.5. Logging Into the VM</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#vm-network-info">5.6. VM Network Info</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#image-management">5.7. Image Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="eucalyptus.html#status-of-deployments">5.8. Status of Deployments</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rain.html">4. RAIN</a><ul>
<li class="toctree-l2"><a class="reference internal" href="rain.html#generate-and-register-an-os-image-on-futuregrid-using-the-fg-shell">4.1. Generate and Register an OS Image on FutureGrid using the FG Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="rain.html#futuregrid-standalone-image-repository">4.2. FutureGrid Standalone Image Repository</a></li>
<li class="toctree-l2"><a class="reference internal" href="rain.html#manual-image-customization">4.3. Manual Image Customization</a></li>
<li class="toctree-l2"><a class="reference internal" href="rain.html#rain-manual-pages">4.4. RAIN Manual Pages</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="todolist.html">1. Todo List</a></li>
<li class="toctree-l1"><a class="reference internal" href="plan.html">2. Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="git.html">13. Git</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">11. Building the Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#python">11.1. Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#virtualenv">11.2. Virtualenv</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#create-a-github-local-directory-with-the-manual">11.3. Create a github local directory with the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#install-the-requirements">11.4. Install the Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#all-in-one-setup-script">11.5. All-in-one setup script</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#watchdog">11.6. Watchdog</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#transfering-a-page-from-the-portal-to-rst">11.7. Transfering a page from the portal to RST</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#creating-the-pages-locally">11.8. Creating the pages locally</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#publishing-the-pages">11.9. Publishing the pages</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#jira">11.10. jira</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#portal-link">11.11. Portal link</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#screencast-recording-tips">11.12. Screencast recording tips</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ring.html">1. MPI Ring Program</a></li>
</ul>
</ul>
</li>
              <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">Vampir</a><ul>
<li><a class="reference internal" href="#vampir-on-futuregrid"><strong>Vampir on FutureGrid</strong></a></li>
<li><a class="reference internal" href="#event-based-performance-tracing-and-profiling"><strong>Event-based Performance Tracing and Profiling</strong></a></li>
<li><a class="reference internal" href="#the-open-trace-format-otf"><strong>The Open Trace Format (OTF)</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#getting-started"><strong>Getting Started</strong></a><ul>
<li><a class="reference internal" href="#generation-of-trace-data"><strong>Generation of Trace Data</strong></a></li>
<li><a class="reference internal" href="#enabling-performance-tracing"><strong>Enabling Performance Tracing</strong></a></li>
<li><a class="reference internal" href="#tracing-an-application"><strong>Tracing an Application</strong></a></li>
<li><a class="reference internal" href="#starting-vampir-and-loading-a-trace-file"><strong>Starting Vampir and Loading a Trace File</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basics"><strong>Basics</strong></a><ul>
<li><a class="reference internal" href="#chart-arrangement"><strong>Chart Arrangement</strong></a></li>
<li><a class="reference internal" href="#context-menus"><strong>Context Menus</strong></a></li>
<li><a class="reference internal" href="#zooming"><strong>Zooming</strong></a></li>
<li><a class="reference internal" href="#the-zoom-toolbar"><strong>The Zoom Toolbar</strong></a></li>
<li><a class="reference internal" href="#the-charts-toolbar"><strong>The Charts Toolbar</strong></a></li>
<li><a class="reference internal" href="#properties-of-the-tracefile"><strong>Properties of the Tracefile</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-data-visualization"><strong>Performance Data Visualization</strong></a><ul>
<li><a class="reference internal" href="#timeline-charts"><strong>Timeline Charts</strong></a><ul>
<li><a class="reference internal" href="#master-timeline-and-process-timeline"><strong>Master Timeline and Process Timeline</strong></a></li>
<li><a class="reference internal" href="#counter-data-timeline"><strong>Counter Data Timeline</strong></a></li>
<li><a class="reference internal" href="#performance-radar"><strong>Performance Radar</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#statistical-charts"><strong>Statistical Charts</strong></a><ul>
<li><a class="reference internal" href="#call-tree"><strong>Call Tree</strong></a></li>
<li><a class="reference internal" href="#function-summary"><strong>Function Summary</strong></a></li>
<li><a class="reference internal" href="#process-summary"><strong>Process Summary</strong></a></li>
<li><a class="reference internal" href="#message-summary"><strong>Message Summary</strong></a></li>
<li><a class="reference internal" href="#communication-matrix-view"><strong>Communication Matrix View</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#informational-charts"><strong>Informational Charts</strong></a></li>
<li><a class="reference internal" href="#function-legend"><strong>Function Legend</strong></a><ul>
<li><a class="reference internal" href="#context-view"><strong>Context View</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#information-filtering-and-reduction"><strong>Information Filtering and Reduction</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#customization"><strong>Customization</strong></a><ul>
<li><a class="reference internal" href="#general-preferences"><strong>General Preferences</strong></a></li>
<li><a class="reference internal" href="#appearance"><strong>Appearance</strong></a></li>
<li><a class="reference internal" href="#saving-policy"><strong>Saving Policy</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#footnotes"><strong>Footnotes</strong></a></li>
<li><a class="reference internal" href="#vampirtrace">VampirTrace</a></li>
</ul>
</ul>
</li>
            
            
              
            
            
              <li>
  <a href="_sources/vampir.txt"
     rel="nofollow">Source</a></li>
            
          </ul>

          
            
<form class="navbar-search pull-right" action="search.html" method="get">
  <input type="text" name="q" class="search-query" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
      </div>
    </div>
  </div>

<div class="container">
  
  <div class="section" id="vampir">
<h1>Vampir<a class="headerlink" href="#vampir" title="Permalink to this headline">¶</a></h1>
<p><strong>Introduction</strong></p>
<p>Performance optimization is a key issue for the development of efficient
parallel software applications. Vampir provides a manageable framework
for analysis, which enables developers to quickly display program
behavior at any level of detail. Detailed performance data obtained from
a parallel program execution can be analyzed with a collection of
different performance views. Intuitive navigation and zooming are the
key features of the tool, which help to quickly identify inefficient or
faulty parts of a program code. Vampir implements optimized event
analysis algorithms and customizable displays which enable a fast and
interactive rendering of very complex performance monitoring data.
Ultra-large data volumes can be analyzed with a parallel version of
Vampir, which is available on request. Vampir has a product history of
more than 15 years and is well established on Unix-based HPC systems.
This tool experience is now available for HPC systems that are based on
Microsoft Windows HPC Server 2008. This new Windows edition of Vampir
combines modern scalable event processing techniques with a fully
redesigned graphical user interface.</p>
<div class="section" id="vampir-on-futuregrid">
<h2><strong>Vampir on FutureGrid</strong><a class="headerlink" href="#vampir-on-futuregrid" title="Permalink to this headline">¶</a></h2>
<p>VampirServer is currently available on India
at&nbsp;/N/soft/x86_64/el5/india/vampirserver. &nbsp;The VampirTrace modules are
installed on Alamo, Hotel, India, and Sierra. &nbsp;To load, type &#8216;module
load vampirtrace&#8217;.</p>
</div>
<div class="section" id="event-based-performance-tracing-and-profiling">
<h2><strong>Event-based Performance Tracing and Profiling</strong><a class="headerlink" href="#event-based-performance-tracing-and-profiling" title="Permalink to this headline">¶</a></h2>
<p>In software analysis, the term profiling refers to the creation of
tables which summarize the runtime behavior of programs by means of
accumulated performance measurements. Its simplest variant lists all
program functions in combination with the number of invocations and the
time that was consumed. This type of profiling is also called inclusive
profiling, as the time spent in subroutines is included in the
statistics computation. A commonly applied method for analyzing details
of parallel program runs is to record so-called trace log files during
runtime. The data collection process itself is also referred to as
tracing a program. Unlike profiling, the tracing approach records timed
application events like function calls and message communication as a
combination of timestamp, event type, and event specific data. This
creates a stream of events, which allows very detailed observations of
parallel programs. With this technology, synchronization and
communication patterns of parallel program runs can be traced and
analyzed in terms of performance and correctness. The analysis is
usually carried out in a postmortem step, i. e., after completion of the
program. Needless to say, program traces can also be used to calculate
the profiles mentioned above. Computing profiles from trace data allows
arbitrary time intervals and process groups to be specified. This is in
contrast to <em>fixed profiles accumulated during runtime.</em></p>
</div>
<div class="section" id="the-open-trace-format-otf">
<h2><strong>The Open Trace Format (OTF)</strong><a class="headerlink" href="#the-open-trace-format-otf" title="Permalink to this headline">¶</a></h2>
<p>The Open Trace Format (OTF) was designed as a well-defined trace format
with open, public domain libraries for writing and reading. This open
specification of the trace information provides analysis and
visualization tools like Vampir to operate efficiently at large scale.
The format addresses large applications written in an arbitrary
combination of Fortran77, Fortran (90/95/etc.), C, and C++.</p>
<p><a href="#id9"><span class="problematic" id="id10">|image30|</span></a></p>
<p><strong>Representation of Streams by Multiple Files</strong></p>
<p>OTF uses a special ASCII data representation to encode its data items
with numbers and tokens in hexadecimal code without special prefixes.
That enables a very powerful format with respect to storage size, human
readability, and search capabilities on timed event records. In order to
support fast and selective access to large amounts of performance trace
data, OTF is based on a stream-model, i.e., single separate units
representing segments of the overall data. OTF streams may contain
multiple independent processes, whereas a process belongs to a single
stream exclusively. As shown in the figure, each stream is represented
by multiple files, which store definition records, performance events,
status information, and event summaries separately. A single global
master file holds the necessary information for the process to stream
mappings. Each file name starts with an arbitrary common prefix defined
by the user. The master file is always named {name}.otf. The global
definition file is named {name}.0.def. Events and local definitions are
placed in files {name}.x.events and {name}.x.defs, where the latter
files are optional. Snapshots and statistics are placed in files named
{name}.x.snaps and {name}.x.stats, which are also optional.</p>
<p><strong>Note</strong>: Open the master file (*.otf) to load a trace. When
copying, moving, or deleting traces, it is important to take all
according files into account; otherwise, Vampir will render the whole
trace invalid! Good practice is to hold all files belonging to one trace
in a dedicated directory. Detailed information about the Open Trace
Format can be found in the <a class="reference external" href="http://www.tu-dresden.de/zih/otf%20">*Open Trace Format
(OTF)*&nbsp;documentation</a>.</p>
</div>
</div>
<div class="section" id="getting-started">
<h1><strong>Getting Started</strong><a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<div class="section" id="generation-of-trace-data">
<h2><strong>Generation of Trace Data</strong><a class="headerlink" href="#generation-of-trace-data" title="Permalink to this headline">¶</a></h2>
<p>The generation of trace files for the (Vampir) performance visualization
tool requires a working monitoring system to be attached to your
parallel program. Contrary to Windows HPC Server 2008 — whereby the
performance monitor is integrated into the operating system — recording
performance under Linux is done by a separate performance monitor. We
recommend our VampirTrace monitoring facility, which is available as
open source software. During a program run of an application,
VampirTrace generates an OTF trace file, which can be analyzed and
visualized by Vampir. The VampirTrace library allows MPI communication
events of a parallel program to be recorded in a trace file.
Additionally, certain program-specific events can also be included. To
record MPI communication events, simply relink the program with the
VampirTrace library. A new compilation of the program source code is
only necessary if program-specific events should be added. Detailed
information on the installation and usage of VampirTrace can be found at
<a class="reference external" href="https://portal.futuregrid.org/manual/vampir/trace">VampirTrace</a>.</p>
</div>
<div class="section" id="enabling-performance-tracing">
<h2><strong>Enabling Performance Tracing</strong><a class="headerlink" href="#enabling-performance-tracing" title="Permalink to this headline">¶</a></h2>
<p>To perform measurements with VampirTrace, the application program needs
to be instrumented. VampirTrace handles this automatically by default,
while manual instrumentation is also possible. All the necessary
instrumentation of user functions, MPI, and OpenMP events is handled by
the compiler wrappers of VampirTrace (vtcc, vtcxx, vtf77, vtf90). All
compile and link commands in the used makefile should be replaced by the
VampirTrace compiler wrapper, which performs the necessary
instrumentation of the program and links the suitable VampirTrace
library. Automatic instrumentation is the most convenient method to
instrument your program. Therefore, simply use the compiler wrappers
without any parameters, e.g.:</p>
<blockquote>
<div><div class="highlight-python"><pre>vtf90 hello.f90 -o hello</pre>
</div>
</div></blockquote>
<p>For manual instrumentation with the VampirTrace API, simply include:</p>
<blockquote>
<div><div class="highlight-python"><pre>vt_user.inc (Fortran)

vt_user.h (C, C++)</pre>
</div>
</div></blockquote>
<p>and label any user defined sequence of statements for instrumentation as
follows:</p>
<blockquote>
<div><div class="highlight-python"><pre>VT_USER_START(name) ... VT_USER_END(name)</pre>
</div>
</div></blockquote>
<p>in Fortran and C, respectively, and in C++ as follows:</p>
<blockquote>
<div><div class="highlight-python"><pre>VT_TRACER(``name);</pre>
</div>
</div></blockquote>
<p>Afterwards, use</p>
<blockquote>
<div><div class="highlight-python"><pre>vtcc -DVTRACE hello.c -o hello</pre>
</div>
</div></blockquote>
<p>to combine the manual instrumentation with automatic compiler
instrumentation or</p>
<blockquote>
<div><div class="highlight-python"><pre>vtcc -vt:inst manual -DVTRACE hello.c -o hello</pre>
</div>
</div></blockquote>
<p>to prevent an additional compiler instrumentation.</p>
</div>
<div class="section" id="tracing-an-application">
<h2><strong>Tracing an Application</strong><a class="headerlink" href="#tracing-an-application" title="Permalink to this headline">¶</a></h2>
<p>Running a VampirTrace instrumented application should normally result in
an OTF trace file in the current working directory where the application
was executed. On Linux, Mac OS, and Sun Solaris, the default name of the
trace file will be equal to the application name. For other systems, the
default name is&nbsp;<em>a.otf</em>&nbsp;but can be defined manually by setting the
environment variable VT_FILE_PREFIX to the desired name. After a run
of an instrumented application, the traces of the single processes need
to be unified in terms of timestamps and event IDs. In most cases, this
happens automatically. If it is necessary to perform unification of
local traces manually, use the following command:</p>
<blockquote>
<div><div class="highlight-python"><pre>vtunify &lt;nproc&gt;</pre>
</div>
</div></blockquote>
<p>If VampirTrace was built with support for OpenMP and/or MPI, it is
possible to speed up the unification of local traces significantly. To
distribute the unification on multiple processes, the MPI parallel
version vtunify-mpi can be used as follows:</p>
<blockquote>
<div><div class="highlight-python"><pre>mpirun -np &lt;nranks&gt; vtunify-mpi &lt;nproc&gt;</pre>
</div>
</div></blockquote>
</div>
<div class="section" id="starting-vampir-and-loading-a-trace-file">
<h2><strong>Starting Vampir and Loading a Trace File</strong><a class="headerlink" href="#starting-vampir-and-loading-a-trace-file" title="Permalink to this headline">¶</a></h2>
<p>To open a trace file, from the &#8220;File&#8221; menu, select &#8220;Open...&#8221;. This will
provide the file-open dialog depicted below. It is possible to filter
the files in the list. The file type input selector determines the
visible files. The default &#8220;OTF Trace Files (*.otf )&#8221; shows only files
that can be processed by the tool. All file types can be displayed by
using &#8220;All Files (*)&#8221;. Alternatively, on Windows, a command-line
invocation is possible:</p>
<blockquote>
<div><div class="highlight-python"><pre>C:\Program Files\Vampir\Vampir.exe [trace file]</pre>
</div>
</div></blockquote>
<p>To open multiple trace files at once, you can take them one after
another as command-line arguments:</p>
<blockquote>
<div><div class="highlight-python"><pre>C:\Program Files\Vampir\Vampir.exe [file 1]...[file n]</pre>
</div>
</div></blockquote>
<p>It is also possible to start the application by double-clicking on an
*.otf file (if Vampir was associated with *.otf files during the
installation process). The trace files to be loaded have to be compliant
with the Open Trace Format (OTF) standard. Microsoft HPC Server 2008 is
shipped with the translator program etl2otf.exe, which produces
appropriate input files.</p>
<p><a href="#id11"><span class="problematic" id="id12">|image31|</span></a></p>
<p><strong>Loading a Trace Log File in Vampir</strong></p>
<p>While Vampir is loading the trace file, an empty &#8220;Trace View&#8221; window
with a progress bar at the bottom opens. After Vampir loaded the trace
data completely, a default set of charts will appear. The illustrated
loading process can be interrupted at any point of time by clicking on
the cancel button in the lower right corner. Because events in the trace
file are traversed one after another, the GUI will also open, but will
show only the earliest information from the tracefile. For huge
tracefiles with performance problems assumed to be at the beginning,
this proceeding is a suitable strategy to save time.</p>
<p><a href="#id13"><span class="problematic" id="id14">|image32|</span></a></p>
<p><strong>Progress Bar and Cancel Loading Button</strong></p>
<p>Basic functionality and navigation elements are described
in&nbsp;<a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Basics">Basics</a>.
The available charts and the information provided by them are explained
in&nbsp;<a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Performance_Data_Visualization">Performance_Data_Visualization</a>.</p>
</div>
</div>
<div class="section" id="basics">
<h1><strong>Basics</strong><a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h1>
<p>After loading has been completed, the&nbsp;<em>Trace View</em>&nbsp;window title
displays the trace file&#8217;s name. By default, the&nbsp;<em>Charts</em>&nbsp;toolbar and
the&nbsp;<em>Zoom Toolbar</em>&nbsp;are available.</p>
<p><a href="#id15"><span class="problematic" id="id16">|image33|</span></a></p>
<p><strong>Trace View Window with Charts Toolbar (A) and Zoom Toolbar (B)</strong></p>
<p>Furthermore, the default set of charts is opened automatically after
loading has been finished. The charts can be divided into three groups:
timeline, statistical, and informational charts. Timeline charts show
detailed event-based information for arbitrary time intervals, while
statistical charts reveal accumulated measures computed from the
corresponding event data. Informational charts provide additional or
explanatory information regarding timeline and statistical charts. All
available charts can be opened with the&nbsp;<em>Charts</em>toolbar (explained
in <a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#The_Charts_Toolbar">The Charts
Toolbar</a>).
In the following section, we will explain the basic functions of the
Vampir GUI which are generic to all charts.</p>
<div class="section" id="chart-arrangement">
<h2><strong>Chart Arrangement</strong><a class="headerlink" href="#chart-arrangement" title="Permalink to this headline">¶</a></h2>
<p>The utility of charts can be increased by correlating them and their
provided information. Vampir supports this mode of operation by allowing
you to display multiple charts at the same time. Charts that display a
sequence of events such as the&nbsp;<em>Master Timeline</em>&nbsp;and the&nbsp;<em>Process
Timeline</em>chart are aligned vertically. This alignment ensures that the
temporal relationship of events is preserved across chart boundaries.
The user can arrange the placement of the charts according to his
preferences by dragging them into the desired position. When the left
mouse button is pressed while the mouse pointer is located above a
placement decoration, the layout engine will give visual clues as to
where the chart may be moved. As soon as the user releases the left
mouse button, the chart arrangement will be changed according to his
intentions. The entire procedure is depicted in figures below. The
flexible display architecture also allows increasing or decreasing the
screen space that is used by a chart. Charts of particular interest may
get more space in order to render information in more detail.</p>
<p><a href="#id17"><span class="problematic" id="id18">|image34|</span></a></p>
<p><strong>Moving and Arranging Charts in the Trace View Window</strong></p>
<p><a href="#id19"><span class="problematic" id="id20">|image35|</span></a></p>
<p><strong>Moving and Arranging Charts in the Trace View Window</strong></p>
<p><a href="#id21"><span class="problematic" id="id22">|image36|</span></a></p>
<p><strong>A Custom Chart Arrangement in the Trace View Window</strong></p>
<p><a href="#id23"><span class="problematic" id="id24">|image37|</span></a></p>
<p><strong>Closing (right) and Undocking (left) a Chart</strong></p>
<p>The&nbsp;<em>Trace View</em>&nbsp;window can host an arbitrary number of charts. Charts
can be added by clicking on the respective&nbsp;<em>Charts</em>&nbsp;toolbar icon or
the corresponding&nbsp;<em>Chart</em>&nbsp;menu entry. With a few more clicks, charts
can be combined to a custom chart arrangement. Customized layouts can be
saved as described in&nbsp;<a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Saving_Policy">Saving
Policy</a>.
Every chart can be undocked or closed by clicking the dedicated icon in
its upper right corner. Undocking a chart means to free the chart from
the current arrangement and present it in its own window.</p>
<p><a href="#id25"><span class="problematic" id="id26">|image38|</span></a></p>
<p><strong>Undocking of a Chart</strong></p>
<p><a href="#id27"><span class="problematic" id="id28">|image39|</span></a></p>
<p><strong>Docking a Chart</strong></p>
<p>Considering that labels (e.g., those showing names or values of
functions) often need more space to show their whole text, there is a
further form of resizing/arranging. In order to read labels completely,
it is possible to resize the distribution of space owned by the labels
and the graphical representation in a chart. When one hovers over the
blank space between labels and graphical representation, a moveable
separator appears. After clicking a separator decoration, moving the
mouse while holding the left mouse button causes resizing.</p>
<p><a href="#id29"><span class="problematic" id="id30">|image40|</span></a></p>
<p><strong>Resizing Labels: (A) Hover over a Separator Decoration; (B) Drag and
Drop the Separator</strong></p>
</div>
<div class="section" id="context-menus">
<h2><strong>Context Menus</strong><a class="headerlink" href="#context-menus" title="Permalink to this headline">¶</a></h2>
<p>All of the chart displays have their own context menus with common
entries as well as display-specific ones. In the following section, only
the most common entries will be discussed. A context menu can be
accessed by right clicking in the display window. Common entries are:</p>
<ul class="simple">
<li><strong>Reset Zoom:</strong> Go back to the initial state in horizontal zooming.</li>
<li><strong>Reset Vertical Zoom:</strong> Go back to the initial state in vertical
zooming.</li>
<li><strong>Set Metric:</strong> Change values which should be represented in the
chart, e.g.&nbsp;<em>Exclusive Time</em>&nbsp;to&nbsp;<em>Inclusive Time</em>.</li>
<li><strong>Sort By:</strong>Rearrange values or bars by a certain characteristic.</li>
</ul>
</div>
<div class="section" id="zooming">
<h2><strong>Zooming</strong><a class="headerlink" href="#zooming" title="Permalink to this headline">¶</a></h2>
<p>Zooming is a key feature of Vampir. In most charts it is possible to
zoom in and out to get abstract and detailed views of the visualized
data. In the timeline charts, zooming produces a more detailed view of a
special time interval and therefore reveals new information that could
not be seen in the larger section. Short function calls in the&nbsp;<em>Master
Timeline</em>&nbsp;may not be visible unless an appropriate zooming level has
been reached. If the execution time of these short functions is too
short regarding the pixel resolution of your computer display, the
selection of a shorter time interval is required. Note: Other charts can
be affected when zooming in timeline displays: The interval chosen in a
timeline chart such as&nbsp;<em>Master Timeline</em>&nbsp;or&nbsp;<em>Process Timeline</em>&nbsp;also
defines the time interval for the calculation of accumulated
measurements in the statistical charts. Statistical charts like
the&nbsp;<em>Function Summary</em>&nbsp;provide zooming of statistic values. In these
cases zooming does not affect any other chart. Zooming is disabled in
the&nbsp;<em>Pie Chart</em>&nbsp;mode of the&nbsp;<em>Function Summary</em>&nbsp;reachable via context
menu under&nbsp;<em>Set Chart Mode-&gt;Pie Chart</em>.</p>
<p><a href="#id31"><span class="problematic" id="id32">|image41|</span></a></p>
<p><strong>Zooming within a Chart</strong></p>
<p>To zoom into an area, click and hold the left mouse button and select
the area. It is possible to zoom horizontally and in some charts also
vertically. Horizontal zooming in the&nbsp;<em>Master Timeline</em>&nbsp;defines the
time interval to be visualized whereas vertical zooming selects a group
of processes to be displayed. To scroll horizontally move the slider at
the bottom or use the mouse wheel. Additionally, the zoom can be
accessed with help of the&nbsp;<em>Zoom Toolbar</em>&nbsp;by dragging the borders of
the selection rectangle or scrolling down the mouse wheel. To return to
the previous zooming state, the global &#8220;Undo&#8221; is provided that in the
&#8220;Edit&#8221; menu; alternatively, press &#8220;Ctrl+Z&#8221; to revert to the last zoom.
Accordingly, a zooming action can be repeated by selecting &#8220;Redo&#8221; in the
&#8220;Edit&#8221; menu or pressing &#8220;Ctrl+Shift+Z&#8221;. Both functions work
independently of the current mouse position. Next to &#8220;Undo&#8221; and &#8220;Redo&#8221;
it is shown which kind of action in which display could be undone and
redone, respectively. To get back to the initial state of zooming in a
fast way select&nbsp;<em>Reset Horizontal Zoom</em>&nbsp;or&nbsp;<em>Reset Vertical Zoom</em>&nbsp;in
the context menu of the desired timeline display. To reset zoom is also
an action that can be reverted by &#8220;Undo&#8221;.</p>
</div>
<div class="section" id="the-zoom-toolbar">
<h2><strong>The Zoom Toolbar</strong><a class="headerlink" href="#the-zoom-toolbar" title="Permalink to this headline">¶</a></h2>
<p>Vampir provides a&nbsp;<em>Zoom Toolbar</em> that can be used for zooming and
navigation in the trace data. It is situated in the upper right corner
of the <em>Trace View</em>&nbsp;window. Of course it is possible to drag and drop it
as desired. The&nbsp;<em>Zoom Toolbar</em>&nbsp;offers an overview of the data
displayed in the corresponding charts. The current zoomed area can be
seen highlighted as a rectangle within the&nbsp;<em>Zoom Toolbar</em>. Clicking on
one of the two boundaries and moving it (with left mouse button held) to
the intended position executes horizontal zooming in all charts.
<strong>Note</strong>: Instead of dragging boundaries, it is also possible to use
the mouse wheel for zooming. Hover over the&nbsp;<em>Zoom Toolbar</em>&nbsp;and scroll
up to zoom in and scroll down to zoom out. Dragging the zoom area
changes the section that is displayed without changing the zoom factor.
For dragging, click in the highlighted zoom area and drag and drop it to
the desired region. If the user double clicks in the&nbsp;<em>Zoom Toolbar</em>,
the initial zooming state is reverted to.</p>
<p><a href="#id33"><span class="problematic" id="id34">|image42|</span></a></p>
<p><strong>Zooming and Navigation within the Zoom Toolbar: (A+B) Zooming in/out
with Mouse Wheel; (C) Scrolling by Moving the Highlighted Zoom Area; (D)
Zooming by Selecting and Moving a Boundary of the Highlighted Zoom
Area</strong></p>
<p>The colors represent user-defined groups of functions or activities.
Please note that all charts added to the&nbsp;<em>Trace View</em>&nbsp;window will
adapt their statistics information according to this time interval
selection. The&nbsp;<em>Zoom Toolbar</em>&nbsp;can be disabled and enabled with the
toolbar&#8217;s context menu entry&nbsp;<em>Zoom Toolbar</em>.</p>
</div>
<div class="section" id="the-charts-toolbar">
<h2><strong>The Charts Toolbar</strong><a class="headerlink" href="#the-charts-toolbar" title="Permalink to this headline">¶</a></h2>
<p>Use the&nbsp;<em>Charts</em>&nbsp;toolbar to open instances of the different charts. It
is situated in the upper left corner of the main window by default. Of
course, it is also possible to drag and drop it as desired.
The&nbsp;<em>Charts</em>&nbsp;toolbar can be disabled with the toolbar&#8217;s context menu
entry&nbsp;<em>Charts</em>. The table below shows the different icons representing
the charts in&nbsp;<em>Charts</em>&nbsp;toolbar. The icons are arranged in three
groups, divided by a small separator. The first group represents
timeline charts, whose zooming states affect all other charts. The
second group consists of statistical charts, providing special
information and statistics for a chosen interval. Vampir allows multiple
instances for charts of these categories. The last group comprises
informational charts, providing specific textual information or legends.
Only one instance of an informational chart can be opened at a time.</p>
<p><strong>Icons of the Toolbar</strong></p>
<p>Icon</p>
<p>Name</p>
<p>Description</p>
<p><a href="#id35"><span class="problematic" id="id36">|image43|</span></a></p>
<p>Master Timeline</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Master_Timeline_and_Process_Timeline">Master
Timeline</a></p>
<p><a href="#id37"><span class="problematic" id="id38">|image44|</span></a></p>
<p>Process Timeline</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Master_Timeline_and_Process_Timeline">Process
Timeline</a></p>
<p><a href="#id39"><span class="problematic" id="id40">|image45|</span></a></p>
<p>Counter Data Timeline</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Counter_Data_Timeline">Counter
Data</a></p>
<p><a href="#id41"><span class="problematic" id="id42">|image46|</span></a></p>
<p>Performance Radar</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Performance_Radar">Performance
Radar</a></p>
<p><a href="#id43"><span class="problematic" id="id44">|image47|</span></a></p>
<p>Function Summary</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Function_Summary">Function
Summary</a></p>
<p><a href="#id45"><span class="problematic" id="id46">|image48|</span></a></p>
<p>Message Summary</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Message_Summary">Message
Summary</a></p>
<p><a href="#id47"><span class="problematic" id="id48">|image49|</span></a></p>
<p>Process Summary</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Process_Summary">Process
Summary</a></p>
<p><a href="#id49"><span class="problematic" id="id50">|image50|</span></a></p>
<p>Communication Matrix View</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Communication_Matrix_View">Communication Matrix
View</a></p>
<p><a href="#id51"><span class="problematic" id="id52">|image51|</span></a></p>
<p>Call Tree</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Call_Tree">Call
Tree</a></p>
<p><a href="#id53"><span class="problematic" id="id54">|image52|</span></a></p>
<p>Function Legend</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Function_Legend">Function
Legend</a></p>
<p><a href="#id55"><span class="problematic" id="id56">|image53|</span></a></p>
<p>Context View</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Context_View">Context
View</a></p>
<p><a href="#id57"><span class="problematic" id="id58">|image54|</span></a></p>
<p>Marker View</p>
<p><a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir#Information_Filtering_and_Reduction">Marker
View</a></p>
</div>
<div class="section" id="properties-of-the-tracefile">
<h2><strong>Properties of the Tracefile</strong><a class="headerlink" href="#properties-of-the-tracefile" title="Permalink to this headline">¶</a></h2>
<p>Vampir provides a display containing the most important
characterizations of the used tracefile. This tabular is called&nbsp;<em>Trace
Properties</em>&nbsp;and can be accessed by&nbsp;<em>File-&gt;Trace Properties</em>. The
information, such as the filename, the creator and its version,
originates from the tracefile and is not changed by Vampir.</p>
</div>
</div>
<div class="section" id="performance-data-visualization">
<h1><strong>Performance Data Visualization</strong><a class="headerlink" href="#performance-data-visualization" title="Permalink to this headline">¶</a></h1>
<p>This chapter deals with the different charts that can be used to analyze
the behavior of a program and the comparison between different function
groups, e.g., MPI and Calculation. In addition, the chapter addresses
communication performance issues. Various charts address the
visualization of data transfers between processes. The following
sections describe them in detail.</p>
<div class="section" id="timeline-charts">
<h2><strong>Timeline Charts</strong><a class="headerlink" href="#timeline-charts" title="Permalink to this headline">¶</a></h2>
<p>A very common chart type used in event-based performance analysis is the
so-called timeline chart. This chart type graphically presents the chain
of events of monitored processes or counters on a horizontal time axis.
Multiple timeline chart instances can be added to the&nbsp;<em>Trace
View</em>&nbsp;window via the&nbsp;<em>Chart</em>&nbsp;menu or the&nbsp;<em>Charts</em>&nbsp;toolbar.</p>
<p><strong>Note</strong>: To measure the duration between two events in a timeline
chart, Vampir provides a tool called ruler. Click on the first event in
a timeline display and move the mouse while keeping the left mouse key
and&nbsp;<em>Shift</em>&nbsp;pressed. A ruler-like pattern appears in the current
timeline chart, which provides rough measurement directly. The exact
time of the start event and the mouse position and the interval in
between is given at the very bottom. If the&nbsp;<em>Shift</em>&nbsp;key is released
before the left mouse key, Vampir will proceed with zooming.</p>
<div class="section" id="master-timeline-and-process-timeline">
<h3><strong>Master Timeline and Process Timeline</strong><a class="headerlink" href="#master-timeline-and-process-timeline" title="Permalink to this headline">¶</a></h3>
<p>In the Master and Process Timelines, detailed information about
functions, communication, and synchronization events is shown. Timeline
charts are available for individual processes (<em>Process Timeline</em>) as
well as for a collection of processes (<em>Master Timeline</em>). The&nbsp;<em>Master
Timeline</em>&nbsp;consists of a collection of rows. Each row represents a single
process, as shown in the figure below. A&nbsp;<em>Process Timeline</em>&nbsp;shows the
different levels of function calls in a stacked bar chart for a single
process, as depicted in the second figure.</p>
<p><a href="#id59"><span class="problematic" id="id60">|image55|</span></a></p>
<p><strong>Master Timeline</strong></p>
<p><a href="#id61"><span class="problematic" id="id62">|image56|</span></a></p>
<p><strong>Process Timeline</strong></p>
<p>Every timeline row consists of a process name on the left and a colored
sequence of function calls or program phases on the right. The color of
a function is defined by its group membership; e.g., MPI_Send()
belonging to the function group MPI has the same color, presumably red,
as MPI_Recv(), which also belongs to the function group MPI. Clicking
on a function highlights it and causes the&nbsp;<em>Context View</em>&nbsp;display to
show detailed information about that particular function, e.g., its
corresponding function group name, time interval, and the complete name.
The&nbsp;<em>Context View</em>&nbsp;display is explained in its own section below. Some
function invocations are very short, and will not show up in the overall
view because of a lack of display pixels. A zooming mechanism is
provided to inspect a specific time interval in more detail. If zooming
is performed, panning in a horizontal direction is possible with the
scroll bar at the bottom. The&nbsp;<em>Process Timeline</em>&nbsp;resembles
the&nbsp;<em>Master Timeline</em>with slight differences. The chart&#8217;s timeline
is divided into levels, which represent the different call stack levels
of function calls. The initial function begins at the first level, a
sub-function called by that function is located a level beneath, and so
forth. If a sub-function returns to its caller, the graphical
representation also returns to the level above. In addition to the
display of categorized function invocations, Vampir&#8217;s
<em>Master</em>&nbsp;and&nbsp;<em>Process Timeline</em>&nbsp;also provide information about
communication events. Messages exchanged between two different processes
are depicted as black lines. In timeline charts, the progress in time is
reproduced from left to right. The leftmost starting point of a message
line and its underlying process bar therefore identify the sender of the
message, whereas the rightmost position of the same line represents the
receiver of the message. The corresponding function calls normally
reflect a pair of MPI communication directives like MPI_Send() and
MPI_Recv(). It is also possible to show a collective communication like
MPI_Allreduce() by selecting one corresponding message as shown in the
figure.</p>
<p><a href="#id63"><span class="problematic" id="id64">|image57|</span></a></p>
<p><strong>Selected MPI Collective in Master Timeline</strong></p>
<p>Additional information like message bursts, markers, and I/O events is
also available. The table shows the symbols and descriptions of these
objects.</p>
<p><strong>Additional Information in Master and Process Timeline</strong></p>
<p><strong>Symbol</strong></p>
<p><strong>Description</strong></p>
<p>Message Burst</p>
<p><a href="#id65"><span class="problematic" id="id66">|image58|</span></a></p>
<p>Because of a lack of pixels it is not possible to display a large number
of messages in a very short interval. Therefore, these messages are
summarized as so-called message bursts. Zooming into this interval
reveals the corresponding single messages.</p>
<p>Markers</p>
<p><a href="#id67"><span class="problematic" id="id68">|image59|</span></a>multiple</p>
<p><a href="#id69"><span class="problematic" id="id70">|image60|</span></a>single</p>
<p>To indicate particular points (like errors or warnings) during the
runtime of an application, markers can be used in a tracefile. They are
drawn as triangles, which are colored according to their types. To
illustrate that two or more markers are placed at the same pixel, a
multiple marker is drawn.</p>
<p>I/O Events</p>
<p><a href="#id71"><span class="problematic" id="id72">|image61|</span></a>multiple</p>
<p><a href="#id73"><span class="problematic" id="id74">|image62|</span></a>single</p>
<p><a href="#id75"><span class="problematic" id="id76">|image63|</span></a>single, selected</p>
<p>Vampir shows detailed information about I/O operations, if they are
included in the tracefile. I/O events are depicted as triangles at the
beginning of an I/O interval. Multiple I/O events are tricolored and
occupy a line to the end of the interval. To see the whole interval of a
single I/O event, the triangle has to be selected. In that case, a
second triangle at the end of the interval appears.</p>
<p>Since the&nbsp;<em>Process Timeline</em>&nbsp;reveals information of one process only,
short black arrows are used to indicate outgoing communication. Clicking
on message lines or arrows shows message details like sender process,
receiver process, message length, message duration, and message tag in
the&nbsp;<em>Context View</em>&nbsp;display.</p>
</div>
<div class="section" id="counter-data-timeline">
<h3><strong>Counter Data Timeline</strong><a class="headerlink" href="#counter-data-timeline" title="Permalink to this headline">¶</a></h3>
<p>Counters are values collected over time to count certain events like
floating point operations or cache misses. Counter values can be used to
store not just hardware performance counters but arbitrary sample
values. There can be counters for different statistical information as
well, for instance, counting the number of function calls or a value in
an iterative approximation of the final result. Counters are defined
during the instrumentation of the application and can be individually
assigned to processes.</p>
<p><a href="#id77"><span class="problematic" id="id78">|image64|</span></a></p>
<p><strong>Counter Data Timeline</strong></p>
<p>The chart is restricted to one counter at a time. It shows the selected
counter for one process. Using multiple instances of the&nbsp;<em>Counter Data
Timeline,</em> counters or processes can be compared easily. The context
menu entry&nbsp;<em>Set Counter</em>&nbsp;allows you to choose the displayed counter
directly from a drop-down list. The entry&nbsp;<em>Set Process</em>&nbsp;selects the
particular process for which the counter is shown.</p>
</div>
<div class="section" id="performance-radar">
<h3><strong>Performance Radar</strong><a class="headerlink" href="#performance-radar" title="Permalink to this headline">¶</a></h3>
<p>The Performance Radar chart provides the search of function occurrences
in the trace file and the extended visualization of counters. It can
happen that a function is not shown in&nbsp;<em>Master</em>&nbsp;and&nbsp;<em>Process
Timeline</em>&nbsp;due to a short runtime. An alternative to zooming is the
option&nbsp;<em>Find Function...</em>. A color-coded timeline indicates the
intervals in which the function is executed.</p>
<p><a href="#id79"><span class="problematic" id="id80">|image65|</span></a></p>
<p><strong>Performance Radar Timeline - Search of Functions</strong></p>
<p>By default, the Performance Radar shows the values of one counter for
each process (thread). In this mode the user can choose between <em>Line
Plot</em>&nbsp;and&nbsp;<em>Color Coded</em>&nbsp;drawing. In the latter case, a color scale on
the bottom provides information about the range of values. Clicking
on&nbsp;<em>Set Counter...</em>&nbsp;leads to a dialog that offers the option of
choosing another counter and calculating the sum or average values.
Summarizing means that the values of the selected counter of all
processes are summed up. The average is this sum divided by the number
of processes. Both options provide a single graph.</p>
<p><a href="#id81"><span class="problematic" id="id82">|image66|</span></a></p>
<p><strong>Performance Radar Timeline - Visualization of Counters</strong></p>
</div>
</div>
<div class="section" id="statistical-charts">
<h2><strong>Statistical Charts</strong><a class="headerlink" href="#statistical-charts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="call-tree">
<h3><strong>Call Tree</strong><a class="headerlink" href="#call-tree" title="Permalink to this headline">¶</a></h3>
<p>The&nbsp;<em>Call Tree</em> illustrates the invocation hierarchy of all monitored
functions in a tree representation. The display reveals information
about the number of invocations of a given function, the time spent in
the different calls, and the caller-callee relationship.</p>
<p><a href="#id83"><span class="problematic" id="id84">|image67|</span></a></p>
<p><strong>Call Tree</strong></p>
<p>The entries of the&nbsp;<em>Call Tree</em>&nbsp;can be sorted in various ways. Simply
click on one header of the tree representation to use its characteristic
to resort the&nbsp;<em>Call Tree</em>. Please note that not all available
characteristics are enabled by default. To add or remove
characteristics, a context menu is accessible by right-clicking on any
of the tree headers. To leaf through the different function calls, it is
possible to fold and unfold the levels of the tree. This can be achieved
by double-clicking a level, or by using the fold level buttons next to
the function name. Functions can be called by many different caller
functions, which is hardly obvious in the tree representation.
Therefore, a relation view shows all callers and callees of the
currently selected function in two separated lists, as shown in the
lower area. To find a certain function by its name, Vampir provides a
search option accessible with the context menu entry&nbsp;<em>Show Find View</em>.
The entered keyword has to be confirmed by pressing the Return key.
The&nbsp;<em>Previous</em>&nbsp;and&nbsp;<em>Next</em>&nbsp;buttons can be used to flip through the
results afterwards.</p>
</div>
<div class="section" id="function-summary">
<h3><strong>Function Summary</strong><a class="headerlink" href="#function-summary" title="Permalink to this headline">¶</a></h3>
<p>The&nbsp;<em>Function Summary</em>&nbsp;chart gives an overview of the accumulated time
consumption across all function groups and functions. For example every
time a process calls the MPI_Send() function, the elapsed time of that
function is added to the MPI function group time. The chart gives a
condensed view on the execution of the application and a comparison
between the different function groups can be made so that dominant
function groups can be distinguished easily.</p>
<p><a href="#id85"><span class="problematic" id="id86">|image68|</span></a></p>
<p><strong>Function Summary</strong></p>
<p>It is possible to change the information displayed via the context menu
entry&nbsp;<em>Set Metric</em>, which offers values like&nbsp;<em>Average Exclusive
Time</em>, <em>Number of Invocations</em>,&nbsp;<em>Accumulated Inclusive Time</em>&nbsp;and
others. Note:&nbsp;<em>Inclusive</em>&nbsp;means the amount of time spent in a function
and all of its subroutines.&nbsp;<em>Exclusive</em>&nbsp;means the amount of time just
spent in this function. The context menu entry&nbsp;<em>Set Event
Category</em>&nbsp;specifies whether either function groups or functions should
be displayed in the chart. The functions own the color of their function
group. It is possible to hide functions and function groups from the
displayed information with the context menu entry&nbsp;<em>Filter</em>. To mark
the function or function group to be filtered, click the associated
label or color representation in the chart. Using the&nbsp;<em>Process
Filter</em>&nbsp;allows you to restrict this view to a set of processes. As a
result, only the consumed time of these processes is displayed for each
function group or function. Instead of using the filter (which affects
all other displays by hiding processes), it is possible to select a
single process via&nbsp;<em>Set Process</em>&nbsp;in the context menu of the <em>Function
Summary</em>. This does not have any effect on other timeline displays.
The&nbsp;<em>Function Summary</em>&nbsp;can be shown as a&nbsp;<em>Histogram</em>&nbsp;(a bar chart,
as in timeline charts) or as a&nbsp;<em>Pie Chart</em>. To switch between these
representations, use the&nbsp;<em>Set Chart Mode</em>&nbsp;entry of the context menu.
The shown functions or function groups can be sorted by name or value
via the context menu option&nbsp;<em>Sort By</em>.</p>
</div>
<div class="section" id="process-summary">
<h3><strong>Process Summary</strong><a class="headerlink" href="#process-summary" title="Permalink to this headline">¶</a></h3>
<p>The&nbsp;<em>Process Summary</em>&nbsp;is similar to the&nbsp;<em>Function Summary</em>&nbsp;but shows
the information for every process independently.</p>
<p><a href="#id87"><span class="problematic" id="id88">|image69|</span></a></p>
<p><strong>Process Summary</strong></p>
<p>This is useful for analyzing the balance between processes to reveal
bottlenecks. For instance, finding that one process spends a
significantly high time performing the calculations could indicate an
unbalanced distribution of work that can slow down the entire
application. The context menu entry&nbsp;<em>Set Event Category</em>&nbsp;specifies
whether either function groups or functions should be displayed in the
chart. The functions own the color of their function group. The chart
can calculate the analysis based on&nbsp;<em>Exclusive Time</em>&nbsp;or&nbsp;<em>Inclusive
Time</em>. To change between these two modes, use the context menu
entry&nbsp;<em>Set Metric</em>. It is possible to hide functions and function
groups from the displayed information with the context menu
entry&nbsp;<em>Filter</em>. To mark the function or function group to be filtered,
click on the associated color representation in the chart. Using
the&nbsp;<em>Process Filter</em>&nbsp;allows you to restrict this view to a set of
processes.</p>
</div>
<div class="section" id="message-summary">
<h3><strong>Message Summary</strong><a class="headerlink" href="#message-summary" title="Permalink to this headline">¶</a></h3>
<p>The&nbsp;<em>Message Summary</em>&nbsp;is a statistical chart showing an overview of
the different messages grouped by certain characteristics.</p>
<p><a href="#id89"><span class="problematic" id="id90">|image70|</span></a></p>
<p><strong>Message Summary Chart with metric set to&nbsp;*Message Transfer
Rate*&nbsp;showing the average transfer rate&nbsp;(A), and the minimal/maximal
transfer rate&nbsp;(B)</strong></p>
<p>All values are represented in a bar chart fashion. The number next to
each bar is the group base, while the number inside a bar depicts the
different values depending on the chosen metric. Therefore, the&nbsp;<em>Set
Metric</em>&nbsp;sub-menu of the context menu can be used to switch between
<em>Aggregated Message Volume</em>,&nbsp;<em>Message Size</em>,&nbsp;<em>Number of Messages</em>,
and&nbsp;<em>Message Transfer Rate</em>. The group base can be changed via the
context menu entry&nbsp;<em>Group By</em>. It is possible to choose
between&nbsp;<em>Message Size</em>,&nbsp;<em>Message Tag</em>, and&nbsp;<em>Communicator (MPI)</em>.</p>
<p><strong>Note</strong>: There will be one bar for every occurring group. However,
if metric is set to&nbsp;<em>Message Transfer Rate</em>, the minimal and the
maximal transfer rate is given in an additional bar beneath the one
showing the average transfer rate. The additional bar starts at the
minimal rate and ends at the maximal one. To filter out messages, click
on the associated label or color representation in the chart and
choose&nbsp;<em>Filter</em>&nbsp;from the context menu afterwards.</p>
</div>
<div class="section" id="communication-matrix-view">
<h3><strong>Communication Matrix View</strong><a class="headerlink" href="#communication-matrix-view" title="Permalink to this headline">¶</a></h3>
<p>The&nbsp;<em>Communication Matrix View</em>&nbsp;is another way of analyzing
communication imbalances. It shows information about messages sent
between processes.</p>
<p><a href="#id91"><span class="problematic" id="id92">|image71|</span></a></p>
<p><strong>Communication Matrix View</strong></p>
<p>The chart is realized as a table. Its rows represent the sending
processes while its columns represent the receivers. The color legend on
the right indicates the displayed values. Depending on the displayed
information, the color legend changes. It is possible to change the type
of displayed values. Different metrics like the average duration of
messages passed from sender to recipient or minimum and maximum
bandwidth are offered. To change the type of value that is displayed,
use the context menu option&nbsp;<em>Set Metric</em>. Use the&nbsp;<em>Process
Filter</em>&nbsp;to define which processes/groups should be displayed.</p>
<p><strong>Note</strong>: A high duration is not automatically caused by a slow
communication path between two processes, but can also be due to the
fact that the time between starting transmission and successful
reception of the message can be increased by a recipient that delays
reception for some reason. This will cause the duration to increase (by
this delay) and the message rate, which is the size of the message
divided by the duration, to decrease accordingly.</p>
</div>
</div>
<div class="section" id="informational-charts">
<h2><strong>Informational Charts</strong><a class="headerlink" href="#informational-charts" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="function-legend">
<h2><strong>Function Legend</strong><a class="headerlink" href="#function-legend" title="Permalink to this headline">¶</a></h2>
<p>The&nbsp;<em>Function Legend</em>&nbsp;lists all visible function groups of the loaded
trace file along with its corresponding color.</p>
<p><a href="#id93"><span class="problematic" id="id94">|image72|</span></a></p>
<p><strong>Function Legend</strong></p>
<p>If colors of functions are changed, they appear in a tree-like fashion
under their respective function group as well.</p>
<p><a href="#id95"><span class="problematic" id="id96">|image73|</span></a></p>
<p><strong>A chosen marker (A) and its representation in the Marker View (B)</strong></p>
<p>The display is given in a tree-like fashion and organizes the marker
events in their respective groups and types. Additional information,
like the time of occurrence in the trace file and its description, is
provided for each marker. By clicking on a marker event in the&nbsp;<em>Marker
View</em>, this event gets selected in the timeline displays that are
currently open, and vice-versa. If this marker event is not visible, the
zooming area jumps to this event automatically. It is possible to select
markers and types. Then all events belonging to that marker or type get
selected in the&nbsp;<em>Master Timeline</em>&nbsp;and the&nbsp;<em>Process Timeline</em>.
If&nbsp;<em>Ctrl</em>&nbsp;or&nbsp;<em>Shift</em>&nbsp;is pressed, the user can highlight several
events. In this case, the user can fit the borders of the zooming area
in the timeline charts to the timestamps of the two marker events that
were chosen at last.</p>
<div class="section" id="context-view">
<h3><strong>Context View</strong><a class="headerlink" href="#context-view" title="Permalink to this headline">¶</a></h3>
<p><a href="#id97"><span class="problematic" id="id98">|image74|</span></a></p>
<p><strong>Context View, showing context information (B) of a selected function
(A)</strong></p>
<p>As implied by its name, the&nbsp;<em>Context View</em>&nbsp;provides more detailed
information of a selected object compared to its graphical
representation. An object, e.g., a function, function group, message, or
message burst, can be selected directly in a chart by clicking its
graphical representation. For different types of objects, different
context information is provided by the&nbsp;<em>Context View</em>. For example,
the object-specific information for functions holds properties
like&nbsp;<em>Interval Begin</em>,&nbsp;<em>Interval End</em>, and&nbsp;<em>Duration</em>.
The&nbsp;<em>Context View</em>&nbsp;may contain several tabs, and a new empty one can
be added by clicking on the&nbsp;<em>add</em>-symbol on the right hand side. If an
object in another chart is selected, its information is displayed in the
current tab. If the&nbsp;<em>Context View</em>&nbsp;is closed, it opens automatically
in that moment. The&nbsp;<em>Context View</em>&nbsp;offers a comparison between the
information that is displayed in different tabs. Just use the&nbsp;<em>=</em>&nbsp;on
the left hand side and choose two objects in the emerged dialog. It is
possible to compare different elements from different charts, which can
be useful in some cases. The comparison shows a list of common
properties. The corresponding values are displayed, along with their
difference if the values are numbers. The first line always shows the
names of the displays.</p>
<p><a href="#id99"><span class="problematic" id="id100">|image75|</span></a></p>
<p><strong>Comparison between Context Information</strong></p>
</div>
</div>
<div class="section" id="information-filtering-and-reduction">
<h2><strong>Information Filtering and Reduction</strong><a class="headerlink" href="#information-filtering-and-reduction" title="Permalink to this headline">¶</a></h2>
<p>Due to the large amount of information that can be stored in trace
files, it is usually necessary to reduce the displayed information
according to some filter criteria. In Vampir, there are different ways
of filtering. It is possible to limit the displayed information to a
certain choice of processes or to specific types of communication
events, e.g., to certain types of messages or collective operations.
Deselecting an item in a filter means that this item is fully masked. In
Vampir, filters are global. Therefore, masked items will no longer show
up in any chart. Filtering not only affects the different charts, but
also the <em>Zoom Toolbar. The different filters can be reached via
the&nbsp;</em>Filter <em>entry in the main menu.</em></p>
<p>The example below shows a typical process representation in
the&nbsp;<em>Process Filter</em>&nbsp;window. This kind of representation is equal to
all other filters. Processes can be filtered by their&nbsp;<em>Process
Group</em>,&nbsp;<em>Communicators</em>&nbsp;and&nbsp;<em>Process Hierarchy</em>. Items to be filtered
are arranged in a spreadsheet representation. In addition to selecting
or deselecting an entire group of processes, it is certainly possible to
filter single processes.</p>
<p><a href="#id101"><span class="problematic" id="id102">|image76|</span></a></p>
<p><strong>Process Filter</strong></p>
<p>Different selection methods can be used in a filter. The check
box&nbsp;<em>Include/Exclude All</em>&nbsp;either selects or deselects every item.
Specific items can be selected/deselected by clicking the check box next
to it. Furthermore, it is possible to select/deselect multiple items at
once; mark the desired entries by clicking their names while holding
either the&nbsp;<em>Shift</em>&nbsp;or the&nbsp;<em>Ctrl</em>&nbsp;key. By holding the&nbsp;<em>Shift</em>&nbsp;key
every item in between the two clicked items will be marked. Holding
the&nbsp;<em>Ctrl</em>&nbsp;key, on the other hand, enables you to add or remove
specific items from/to the marked ones. Clicking the check box of one of
the marked entries will cause selection/deselection for all of them.</p>
<p><strong>Options of Filtering</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Filter Object</strong></td>
<td><strong>Filter Criteria</strong></td>
</tr>
<tr class="row-even"><td>Processes</td>
<td>Process Groups</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Communicators</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Process Hierarchy</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Single Processes</td>
</tr>
<tr class="row-even"><td>Collective Operations</td>
<td>Communicators</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Collective Operations</td>
</tr>
<tr class="row-even"><td>Messages</td>
<td>Message Communicators</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Message Tags</td>
</tr>
<tr class="row-even"><td>I/O Events</td>
<td>I/O Groups</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Files</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Types</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="customization">
<h1><strong>Customization</strong><a class="headerlink" href="#customization" title="Permalink to this headline">¶</a></h1>
<p>The appearance of the trace file and various other application settings
can be altered in the preferences accessible via the main menu entry
<em>File-&gt;Preferences</em>. Settings concerning the trace file itself, e.g.,
layout or function group colors, are saved individually next to the
tracefile in a file, whose end is&nbsp;<em>.vsettings</em>. In this way, it is
possible to adjust the colors for one trace file without interfering
with other trace files. The options <em>Import Preferences</em>&nbsp;and&nbsp;<em>Export
Preferences</em>&nbsp;provide the loading and saving of preferences of arbitrary
tracefiles.</p>
<div class="section" id="general-preferences">
<h2><strong>General Preferences</strong><a class="headerlink" href="#general-preferences" title="Permalink to this headline">¶</a></h2>
<p>The&nbsp;<em>General</em>&nbsp;settings allow you to change application and trace
specific values.</p>
<p><a href="#id103"><span class="problematic" id="id104">|image77|</span></a></p>
<p><strong>General Settings</strong></p>
<p><em>Show time as</em>decides whether the time format for the trace analysis
is based on seconds or ticks. The next point&nbsp;<em>Use color gradient in
charts</em>allows you to switch off the color gradient used in the
performance charts. The next option is to change the style and size of
the font.&nbsp;<em>Show source code</em> allows you to open an editor showing the
respective source file. In order to open a source file, first click on
the intended function in the&nbsp;<em>Master Timeline</em>&nbsp;and then on the source
code path in the&nbsp;<em>Context View</em>. For the source code location to work
properly, you need a trace file with source code location support. The
path of the source file can be adjusted in&nbsp;<em>Preferences</em>. A limit for
the size of the file can be set, too. Finally, the user can decide if he
wants Vampir to automatically check for new versions.</p>
</div>
<div class="section" id="appearance">
<h2><strong>Appearance</strong><a class="headerlink" href="#appearance" title="Permalink to this headline">¶</a></h2>
<p>In the&nbsp;<em>Appearance</em>&nbsp;settings of the&nbsp;<em>Preferences</em>&nbsp;dialog, there are
six different objects for which the color options can be changed: the
functions/function groups, markers, counters, collectives, messages and
I/O events. Choose an entry and click on its color to make a
modification. A color picker dialog opens where it is possible to adjust
the color. For messages and collectives, a change of the line width is
also available.</p>
<p><a href="#id105"><span class="problematic" id="id106">|image78|</span></a></p>
<p><strong>Appearance Settings</strong></p>
<p>In order to quickly find the desired item a search box is provided at
the bottom of the dialog.</p>
</div>
<div class="section" id="saving-policy">
<h2><strong>Saving Policy</strong><a class="headerlink" href="#saving-policy" title="Permalink to this headline">¶</a></h2>
<p>Vampir detects whenever changes to the various settings are made. In
the&nbsp;<em>Saving Policy</em>&nbsp;dialog it is possible to adjust the saving
behavior of the different components to your own needs.</p>
<p><strong>Saving Policy Settings</strong></p>
<div class="line-block">
<div class="line">In the dialog&nbsp;<em>Saving Behavior</em>&nbsp;you tell Vampir what to do in the</div>
</div>
<p>case of changed preferences. The user can choose the categories of
settings (e.g., layout) that should be treated. Possible options are
that the application automatically&nbsp;<em>Always</em>&nbsp;or&nbsp;<em>Never</em>&nbsp;saves changes.
The default option is to have Vampir asking you whether to save or
discard changes. Usually the settings are stored in the folder of the
tracefile. If the user has no access to it, it is possible to place them
in the&nbsp;<em>Application Data Folder</em>. They are listed in the
tab&nbsp;<em>Locally Stored Preferences</em>&nbsp;with creation and modification date.
|
<strong>Note</strong>: On loading, Vampir favors settings in the&nbsp;<em>Application
Data Folder</em>.&nbsp;<em>Default Preferences</em>&nbsp;offers to save preferences of the
current trace file as default settings, where they are then used for
tracefiles without settings. Another option is to restore the default
settings; in this case, the current preferences of the tracefile are
reverted.</p>
</div>
</div>
<div class="section" id="footnotes">
<h1><strong>Footnotes</strong><a class="headerlink" href="#footnotes" title="Permalink to this headline">¶</a></h1>
<p>Additional links that might be of interest to the reader:</p>
<p>...
(OTF)&nbsp;<a class="reference external" href="http://www.tu-dresden.de/zih/otf">http://www.tu-dresden.de/zih/otf</a></p>
<p>...
WindowsHPC&nbsp;<a class="reference external" href="http://resourcekit.windowshpc.net/MORE_INFO/TracingMPIApplications.html">http://resourcekit.windowshpc.net/MORE_INFO/TracingMPIApplications.html</a></p>
<p>...
Manual&nbsp;<a class="reference external" href="http://www.tu-dresden.de/zih/vampirtrace">http://www.tu-dresden.de/zih/vampirtrace</a></p>
<p>Retrieved from
&#8220;<a class="reference external" href="https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir">https://wiki.futuregrid.org/index.php/Docs/Performance/Vampir</a>&#8220;</p>
</div>
<div class="section" id="vampirtrace">
<h1>VampirTrace<a class="headerlink" href="#vampirtrace" title="Permalink to this headline">¶</a></h1>
<p>VampirTrace consists of a tool set and a runtime library for
instrumentation and tracing of software applications. It is particularly
tailored to parallel and distributed High Performance Computing (HPC)
applications.</p>
<p><strong>Availability</strong><a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">**</span></a></p>
<p>VampirTrace is currently available on FutureGrid machines under module
&#8216;vampirtrace&#8217;. VampirTrace is also available in OpenMPI versions 1.5.x
or higher. For example on Bravo, it is available as <em>openmpi/1.5.4-gnu</em>
or <em>openmpi/1.5.4-intel</em>.</p>
<p><strong>Overview</strong><a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">**</span></a></p>
<p>The instrumentation part of VampirTrace modifies a given application in
order to inject additional measurement calls during runtime. The tracing
part provides the actual measurement functionality used by the
instrumentation calls. By this means, a variety of detailed performance
properties can be collected and recorded during runtime. This includes
function enter and leave events, MPI communication, OpenMP events, and
performance counters.</p>
<p>After a successful tracing run, VampirTrace writes all collected data to
a trace file in the Open Trace Format (OTF). As a result, the
information is available for post-mortem analysis and visualization by
various tools. Most notably, VampirTrace provides the input data for the
Vampir analysis and visualization tool.</p>
<p>Trace files can quickly become very large, especially with automatic
instrumentation. Tracing applications for only a few seconds can result
in trace files of several hundred megabytes. To protect users from
creating trace files of several gigabytes, the default behavior of
VampirTrace limits the internal buffer to 32MB per process (2GB on
FutureGrid systems). Thus, even for larger scale runs the total trace
file size will be moderate.</p>
<p>The following list shows a summary of all instrumentation and tracing
features that VampirTrace offers. Note that not all features are
supported on all platforms.</p>
<p><strong>Tracing of User Functions</strong></p>
<ul class="simple">
<li>Record function enter and leave events</li>
<li>Record name and source code location (file name, line)</li>
<li>Manual instrumentation using VampirTrace API</li>
</ul>
<p><strong>MPI Tracing</strong></p>
<ul class="simple">
<li>Record MPI functions</li>
<li>Record MPI communication: participating processes, transferred bytes,
tag, communicator</li>
</ul>
<p><strong>OpenMP Tracing</strong></p>
<ul class="simple">
<li>OpenMP directives, synchronization, thread idle time</li>
<li>Also hybrid (MPI and OpenMP) applications are supported</li>
</ul>
<p><strong>Pthread Tracing</strong></p>
<ul class="simple">
<li>Trace POSIX thread API calls</li>
<li>Also hybrid (MPI and POSIX threads) applications are supported</li>
</ul>
<p><strong>Java Tracing</strong></p>
<ul class="simple">
<li>Record method calls</li>
<li>Using JVMTI as interface between VampirTrace and Java Applications</li>
</ul>
<p><strong>3rd-Party Library tracing</strong></p>
<ul class="simple">
<li>Trace calls to arbitrary third party libraries</li>
<li>Generate wrapper for library functions based on library’s header
file(s)</li>
<li>No recompilation of application or library is required</li>
</ul>
<p><strong>MPI Correctness Checking</strong></p>
<ul class="simple">
<li>Record MPI usage errors</li>
<li>Using UniMCI as interface between VampirTrace and a MPI correctness
checking tool (e.g., Marmot)</li>
</ul>
<p><strong>User API</strong></p>
<ul class="simple">
<li>Manual instrumentation of source code regions</li>
<li>Measurement controls</li>
<li>User-defined counters</li>
<li>User-defined marker</li>
</ul>
<p><strong>Performance Counters</strong></p>
<ul class="simple">
<li>Hardware performance counters using PAPI, CPC, or NEC SX performance
counter</li>
<li>Resource usage counters using getrusage</li>
</ul>
<p><strong>Memory Tracing</strong></p>
<ul class="simple">
<li>Trace GLIBC memory allocation and free functions</li>
<li>Record size of currently allocated memory as counter</li>
</ul>
<p><strong>I/O Tracing</strong></p>
<ul class="simple">
<li>Trace LIBC I/O calls</li>
<li>Record I/O events: file name, transferred bytes</li>
</ul>
<p><strong>CPU ID Tracing</strong></p>
<ul class="simple">
<li>Trace core ID of a CPU on which the calling thread is running</li>
<li>Record core ID as counter</li>
</ul>
<p><strong>Fork/System/Exec Tracing</strong></p>
<ul class="simple">
<li>Trace applications calling LIBC’s fork, system, or one of the exec
functions</li>
<li>Add forked processes to the trace</li>
</ul>
<p><strong>Filtering &amp; Grouping</strong></p>
<ul class="simple">
<li>Runtime and post-mortem filter (i.e., exclude functions from being
recorded in the trace)</li>
<li>Runtime grouping (i.e., assign functions to groups for improved
analysis)</li>
</ul>
<p><strong>OTF Output</strong></p>
<ul class="simple">
<li>Writes compressed OTF files</li>
<li>Output as trace file, statistical summary (profile), or both</li>
</ul>
<p><strong>Instrumentation</strong></p>
<p>To perform measurements with VampirTrace, the user&#8217;s application program
needs to be instrumented; that is, at specific points of interest
(called &#8220;events&#8221;), VampirTrace measurement calls have to be activated.
Common events are, among others, entering and leaving of functions as
well as sending and receiving of MPI messages. VampirTrace handles this
automatically by default. In order to enable the instrumentation of
function calls, the user needs only to replace the compiler and linker
commands with VampirTrace’s wrappers (see below). VampirTrace supports
different ways of instrumentation as described in the sections below.</p>
<p><strong>Compiler Wrappers</strong></p>
<p>All the necessary instrumentation of user functions, MPI, and OpenMP
events is handled by VampirTrace’s compiler wrappers (vtcc, vtcxx,
vtf77, and vtf90). In the script used to build the application (e.g., a
makefile), all compile and link commands should be replaced by the
VampirTrace compiler wrapper. The wrappers perform the necessary
instrumentation of the program and link the suitable VampirTrace
library. The following list shows some examples specific to the
parallelization type of the program:</p>
<ul class="simple">
<li>Serial programs</li>
</ul>
<p>Compiling serial codes is the default behavior of the wrappers. Simply
replace the compiler by VampirTrace’s wrapper:</p>
<p>original:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gfortran hello.f90 -o hello</p>
<p>with instrumentation: <strong>vtf90</strong> hello.f90 -o hello</p>
<p>This will instrument user functions (if supported by the compiler) and
link the VampirTrace library.</p>
<ul class="simple">
<li>MPI parallel programs</li>
</ul>
<p>MPI instrumentation is always handled by means of the PMPI interface,
which is part of the MPI standard. This requires the compiler wrapper to
link with an MPI-aware version of the VampirTrace library. If your MPI
implementation uses special MPI compilers (e.g. mpicc, mpxlf90), you
will need to tell VampirTrace’s wrapper to use this compiler instead of
the serial one:</p>
<p>original:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpicc hello.c -o hello</p>
<p>with instrumentation: <strong>vtcc -vt:cc mpicc</strong> hello.c -o hello</p>
<p>MPI implementations without their own compilers require the user to link
the MPI library manually. In this case, simply replace the compiler by
VampirTrace’s compiler wrapper:</p>
<p>original:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icc hello.c -o hello –lmpi</p>
<p>with instrumentation: <strong>vtcc</strong> hello.c -o hello -lmpi</p>
<p>If you want to instrument MPI events only (this creates smaller trace
files and less overhead), use the option <em>-vt:inst manual</em> to disable
automatic instrumentation of user functions.</p>
<ul class="simple">
<li>Threaded parallel programs</li>
</ul>
<p>When VampirTrace detects OpenMP or Pthread flags on the command line,
special instrumentation calls are invoked. For OpenMP events, OPARI is
invoked for automatic source code instrumentation.</p>
<p>original:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifort &lt;-openmp|-pthread&gt; hello.f90 -o hello</p>
<p>with instrumentation: <strong>vtf90</strong> &lt;-openmp|-pthread&gt; hello.f90 -o hello</p>
<p>For more information about OPARI, read the documentation available in
VampirTrace’s installation directory at:
<a class="reference external" href="http://share/vampirtrace/doc/opari/Readme.html%20">share/vampirtrace/doc/opari/Readme.html</a></p>
<ul class="simple">
<li>Hybrid MPI/Threaded parallel programs</li>
</ul>
<p>With a combination of the above mentioned approaches, hybrid
applications can be instrumented:</p>
<p>original:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpif90 &lt;-openmp|-pthread&gt; hello.F90 -o
hello</p>
<p>with instrumentation: <strong>vtf90 -vt:f90 mpif90</strong> &lt;-openmp|-pthread&gt;
hello.F90 -o hello</p>
<p>The VampirTrace compiler wrappers automatically try to detect which
parallelization method is used by means of the compiler flags (e.g.,
-lmpi, -openmp or -pthread) and the compiler command (e.g. mpif90). If
the compiler wrapper failed to detect this correctly, the
instrumentation could be incomplete and an unsuitable VampirTrace
library would be linked to the binary. In this case, you should tell the
compiler wrapper which parallelization method your program uses by using
the switches -vt:mpi, -vt:mt, and -vt:hyb for MPI, multithreaded, and
hybrid programs, respectively. Note that these switches do not change
the underlying compiler or compiler flags. Use the option -vt:verbose to
see the command line that the compiler wrapper executes.</p>
<p>The default settings of the compiler wrappers can be modified in the
files <em>share/vampirtrace/vtcc-wrapper-data.txt</em> (and similar for the
other languages) in the installation directory of VampirTrace. The
settings include compilers, compiler flags, libraries, and
instrumentation types. You could, for instance, modify the default C
compiler from gcc to mpicc by changing the line <em>compiler=gcc</em> to
<em>compiler=mpicc</em>. This may be convenient if you instrument MPI parallel
programs only.</p>
<p><strong>Instrumentation Types</strong></p>
<p>The wrapper option <em>-vt:inst &lt;insttype&gt;</em> specifies the instrumentation
type to be used. The following values for <em>&lt;insttype&gt;</em> are possible:</p>
<ul class="simple">
<li>compinst</li>
</ul>
<p>Fully-automatic instrumentation by the compiler</p>
<ul class="simple">
<li>manual</li>
</ul>
<p>Manual instrumentation by using VampirTrace’s API (needs source-code
modifications)</p>
<p><strong>Automatic Instrumentation</strong></p>
<p>Automatic instrumentation is the most convenient method to instrument
your program. If available, simply use the compiler wrappers without any
parameters, e.g.:</p>
<p>vtf90 hello.f90 -o hello</p>
<p><strong>Notes for Using the GNU or Intel Compiler</strong></p>
<p>For these compilers, the command nm is required to get symbol
information of the running application executable. To get the
application executable for nm during runtime, VampirTrace uses the /proc
file system. As /proc is not present on all operating systems, automatic
symbol information might not be available. In this case, it is necessary
to set the environment variable VT APPPATH to the pathname of the
application executable to get symbols resolved via nm.</p>
<p>Should any problems emerge to get symbol information automatically, then
the environment variable VT GNU NMFILE can be set to a symbol list file,
which is created with the command nm, like:</p>
<p>nm hello &gt; hello.nm</p>
<p>To get the source code line for the application functions use nm -l (on
Linux systems). VampirTrace will include this information in the trace.
Note that the output format of nm must be written in BSD-style. See the
manual page of nm for help in dealing with the output format setting.</p>
<p><strong>Notes on Instrumentation of Inline Functions</strong></p>
<p>Compilers behave differently when they automatically instrument inlined
functions. The GNU and Intel (10.0++) compilers instrument all functions
by default when they are used with VampirTrace. They therefore switch
off inlining completely, disregarding the optimization level chosen. One
can prevent these particular functions from being instrumented by
appending the following attribute to function declarations, hence making
them able to be inlined (this works only for C/C++):</p>
<p>__attribute__ ((__no_instrument_function__))</p>
<p>The PGI and IBM compilers prefer inlining over instrumentation when
compiling with enabled inlining. Thus, one needs to disable inlining to
enable the instrumentation of inline functions and vice versa.</p>
<p>The bottom line is that a function cannot be inlined and instrumented at
the same time. Note that you can also use the option <em>-vt:inst manual</em>
with non-instrumented sources. Binaries created in this manner only
contain MPI and OpenMP instrumentation, which might be desirable in some
cases. For more on how to inline functions, read your compiler’s manual.</p>
<p><strong>Manual Instrumentation</strong></p>
<p><strong>Using the VampirTrace API</strong></p>
<p>The <em>VT USER START, VT USER END</em> calls can be used to instrument any
user-defined sequence of statements.</p>
<p>Fortran</p>
<p>#include &#8220;vt_user.inc&#8221;</p>
<p>VT_USER_START(’name’)</p>
<p>...</p>
<p>VT_USER_END(’name’)</p>
<p>C</p>
<p>#include &#8220;vt_user.h&#8221;</p>
<p>VT_USER_START(&#8220;name&#8221;);</p>
<p>...</p>
<p>VT_USER_END(&#8220;name&#8221;);</p>
<p>If a block has several exit points (as is often the case for functions),
all exit points have to be instrumented with VT USER END, too.</p>
<p>For C++ it is simpler, as is demonstrated in the following example. Only
entry points into a scope need to be marked. The exit points are
detected automatically when C++ deletes scope-local variables.</p>
<p>C++</p>
<p>#include &#8220;vt_user.h&#8221;</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; VT_TRACER(&#8220;name&#8221;);</p>
<p>&nbsp;&nbsp;&nbsp; ...</p>
<p>}</p>
<p>The instrumented sources have to be compiled with -DVTRACE for all three
languages; otherwise the VT * calls are ignored. Note that Fortran
source files instrumented this way have to be preprocessed, too.</p>
<p>In addition, you can combine this particular instrumentation type with
all other types. In such a way, all user functions can be instrumented
by a compiler while special source code regions (e.g., loops) can be
instrumented by VT’s API.</p>
<p>Use VT’s compiler wrapper (described above) for compiling and linking
the instrumented source code, such as:</p>
<ul class="simple">
<li>combined with automatic compiler instrumentation:</li>
</ul>
<p>vtcc <strong>-DVTRACE</strong> hello.c -o hello</p>
<ul class="simple">
<li>without compiler instrumentation:</li>
</ul>
<p>vtcc -vt:inst manual <strong>-DVTRACE</strong> hello.c -o hello</p>
<p>Note that you can also use the option -vt:inst manual with
non-instrumented sources. Binaries created in this manner only contain
MPI and OpenMP instrumentation, which might be desirable in some cases.</p>
<p><strong>Measurement Controls</strong></p>
<p><strong>Switching Tracing On/Off:</strong> In addition to instrumenting arbitrary
blocks of code, one can use the VT_ON/ VT_OFF instrumentation calls to
start and stop the recording of events. These constructs can be used to
stop recording of events for a part of the application and later resume
recording. For example, one could not collect trace events during the
initialization phase of an application and turn on tracing for the
computation part.</p>
<p>Furthermore, the &#8220;on/off&#8221; functionality can be used to control the
tracing behavior of VampirTrace, and allows you to trace only parts of
interests. Essentially, then, the amount of trace data can be reduced.</p>
<p>To check whether if tracing is enabled or not, use the call VT_IS_ON.</p>
<p>Please note that stopping and starting the recording of events has to be
performed at the same call stack level. If this is not the case, an
error message will be printed during runtime, and VampirTrace will abort
execution.</p>
<p><strong>Intermediate Buffer Flush:</strong> In addition to an automated buffer flush
when the buffer is filled, it is possible to flush the buffer at any
point of the application. This way you can guarantee that after a manual
buffer flush there will be a sequence of the program with no automatic
buffer flush interrupting. To flush the buffer, you can use the call
VT_BUFFER_FLUSH.</p>
<p><strong>Intermediate Time Synchronisation:</strong> VampirTrace provides several
mechanisms for timer synchronization. In addition, it is also possible
to initiate a timer synchronization at any point of the application by
calling VT_TIMESYNC. Please note that the user has to ensure that all
processes are actual at a synchronized point in the program (e.g., at a
barrier). To use this call, make sure that the enhanced timer
synchronization is activated (set the environment variable
VT_ETIMESYNC).</p>
<p><strong>Intermediate Counter Update:</strong> VampirTrace provides the functionality
to collect the values of arbitrary hardware counters. Chosen counter
values are automatically recorded whenever an event occurs. Sometimes
(e.g., within a long-lasting function) it is desirable to get the
counter values at an arbitrary point within the program. To record the
counter values at any given point, you can call VT_UPDATE_COUNTER.</p>
<p><strong>Note:</strong> For all three languages the instrumented sources have to be
compiled with -DVTRACE. Otherwise the VT * calls are ignored. In
addition, if the sources contain further VampirTrace API calls and only
the calls for measurement controls will be disabled, then the sources
must also be compiled with -DVTRACE_NO_CONTROL.</p>
<p><strong>Tracing Calls to 3rd-Party Libraries</strong></p>
<p>VampirTrace is also capable of tracing calls to third-party libraries
which come with at least one C header file, even without the library’s
source code. If VampirTrace was built with support for library tracing,
the tool vtlibwrapgen can be used to generate a wrapper library to
intercept each call to the actual library functions. This wrapper
library can be linked to the application, or used in combination with
the LD PRELOAD mechanism provided by Linux. The generation of a wrapper
library is done using the vtlibwrapgen command and consists of two
steps. The first step generates a C source file, providing the wrapped
functions of the library header file:</p>
<p>vtlibwrapgen -g SDL -o SDLwrap.c /usr/include/SDL/*.h</p>
<p>This generates the source file <em>SDLwrap.c</em> that contains
wrapper-functions for all library functions found in the header-files
located in <em>/usr/include/SDL/</em>, and instructs VampirTrace to assign
these functions to the new group SDL. The generated wrapper source file
can be edited in order to add manual instrumentation or alter attributes
of the library wrapper. A detailed description can be found in the
generated source file or in the header file <em>vt libwrap.h</em> , which can
be found in the include directory of VampirTrace. To adapt the library
instrumentation it is possible to pass a filter file to the generation
process. The rules are like these for normal VampirTrace
instrumentation, where only 0 (exclude functions) and -1 (generally
include functions) are allowed.</p>
<p>The second step is to compile the generated source file:</p>
<p>vtlibwrapgen &#8211;build &#8211;shared -o libSDLwrap SDLwrap.c</p>
<p>This builds the shared library <em>libSDLwrap.so</em>, which can be linked to
the application or preloaded by using the environment variable LD
PRELOAD:</p>
<p>LD_PRELOAD=$PWD/libSDLwrap.so &lt;executable&gt;</p>
<p><strong>Runtime Measurement</strong></p>
<p>Running a VampirTrace instrumented application should normally result in
an OTF trace file in the current working directory where the application
was executed. If a problem occurs, set the environment variable
VT_VERBOSE to 2 before executing the instrumented application in order
to see control messages of the VampirTrace runtime system which might
help tracking down the problem.</p>
<p>The internal buffer of VampirTrace is limited to 32 MB per process. Use
the environment variables VT_BUFFER_SIZE and VT_MAX_FLUSHES to
increase this limit.</p>
<p><strong>Trace File Name and Location</strong></p>
<p>The default name of the trace file depends on the operating system where
the application is run. On Linux, MacOS and Sun Solaris, the trace file
will be named like the application, e.g., <em>hello.otf</em>for the
executable hello. For other systems, the default name is <em>a.otf</em>.
Optionally, the trace file name can be defined manually by setting the
environment variable VT_FILE_PREFIX to the desired name. The suffix
.<em>otf</em> will be added automatically.</p>
<p>To prevent overwriting of trace files by repetitive program runs, one
can enable unique trace file naming by setting VT_FILE_UNIQUE to yes.
In this case, VampirTrace adds a unique number to the file names as soon
as a second trace file with the same name is created. A *.lock file is
used to count up the number of trace files in a directory. Be aware that
VampirTrace potentially overwrites an existing trace file if you delete
this lock file. The default value of VT_FILE_UNIQUE is no. You can
also set this variable to a number greater than zero, which will be
added to the trace file name. This way you can manually control the
unique file naming.</p>
<p>The default location of the final trace file is the working directory at
application start time. If the trace file will be stored in another
place, use VT_PFORM_GDIR to change the location of the trace file.</p>
<p><strong>Environment Variables</strong></p>
<p>Environment variables can be used to control nearly every aspect of the
measurement of a VampirTrace instrumented executable. (ToDo: link to
CheatSheet and Doku-PDF)</p>
<p><strong>Variable</strong></p>
<p><strong>Purpose</strong></p>
<p><strong>Default</strong></p>
<p>Global Settings</p>
<p>VT_APPPATH</p>
<p>Path to the application executable.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_BUFFER_SIZE</p>
<p>Size of internal event trace buffer. This is the place where event
records are stored, before being written to a file.</p>
<p>32M</p>
<p>VT_CLEAN</p>
<p>Remove temporary trace files?</p>
<p>yes</p>
<p>VT_COMPRESSION</p>
<p>Write compressed trace files?</p>
<p>yes</p>
<p>VT_FILE_PREFIX</p>
<p>Prefix used for trace filenames.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_FILE_UNIQUE</p>
<p>Enable unique trace file naming? Set to yes, no, or a numerical ID.</p>
<p>no</p>
<p>VT_MAX_FLUSHES</p>
<p>Maximum number of buffer flushes.</p>
<p>1</p>
<p>VT_MAX_THREADS</p>
<p>Maximum number of threads per process that VampirTrace reserves
resources for.</p>
<p>65536</p>
<p>VT_PFORM_GDIR</p>
<p>Name of global directory to store final trace file in.</p>
<p>./</p>
<p>VT_PFORM_LDIR</p>
<p>Name of node-local directory which can be used to store temporary trace
files.</p>
<p>/tmp/</p>
<p>VT_UNIFY</p>
<p>Unify local trace files afterwards?</p>
<p>yes</p>
<p>VT_VERBOSE</p>
<p>Level of VampirTrace related information messages: Quiet (0), Critical
(1), Information (2)</p>
<p>1</p>
<p>Optional Features</p>
<p>VT_CPUIDTRACE</p>
<p>Enable tracing of CPU ID?</p>
<p>no</p>
<p>VT_ETIMESYNC</p>
<p>Enable enhanced timer synchronization? ⇒ Section
[#timer_synchronization [*]]</p>
<p>no</p>
<p>VT_ETIMESYNC_INTV</p>
<p>Interval between two successive synchronization phases in s.</p>
<p>120</p>
<p>VT_IOLIB_PATHNAME</p>
<p>Provides an alternative library to use for LIBC I/O calls.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_IOTRACE</p>
<p>Enable tracing of application I/O calls?</p>
<p>no</p>
<p>VT_LIBCTRACE</p>
<p>Enable tracing of fork/system/exec calls?</p>
<p>yes</p>
<p>VT_MEMTRACE</p>
<p>Enable memory allocation counter?</p>
<p>no</p>
<p>VT_MODE</p>
<p>Colon-separated list of VampirTrace modes: Tracing (TRACE), Profiling
(STAT).</p>
<p>TRACE</p>
<p>VT_MPICHECK</p>
<p>Enable MPI correctness checking via UniMCI?</p>
<p>no</p>
<p>VT_MPICHECK_ERREXIT</p>
<p>Force trace write and application exit if an MPI usage error is
detected?</p>
<p>no</p>
<p>VT_MPITRACE</p>
<p>Enable tracing of MPI events?</p>
<p>yes</p>
<p>VT_PTHREAD_REUSE</p>
<p>Reuse IDs of terminated Pthreads?</p>
<p>yes</p>
<p>VT_STAT_INV</p>
<p>Length of interval for writing the next profiling record</p>
<p>0</p>
<p>VT_STAT_PROPS</p>
<p>Colon-separated list of event types that will be recorded in profiling
mode: Functions (FUNC), Messages (MSG), Collective Ops. (COLLOP) or all
of them (ALL)</p>
<p>ALL</p>
<p>VT_SYNC_FLUSH</p>
<p>Enable synchronized buffer flush?</p>
<p>no</p>
<p>VT_SYNC_FLUSH_LEVEL</p>
<p>Minimum buffer fill level for synchronized buffer flush in percent.</p>
<p>80</p>
<p>Counters</p>
<p>VT_METRICS</p>
<p>Specify counter metrics to be recorded with trace events as a
colon-separated list of names</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_RUSAGE</p>
<p>Colon-separated list of resource usage counters which will be recorded.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_RUSAGE_INTV</p>
<p>Sample interval for recording resource usage counters in ms.</p>
<p>100</p>
<p>Filtering, Grouping</p>
<p>VT_DYN_BLACKLIST</p>
<p>Name of blacklist file for Dyninst instrumentation.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_DYN_SHLIBS</p>
<p>Colon-separated list of shared libraries for Dyninst instrumentation.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_FILTER_SPEC</p>
<p>Name of function/region filter file.</p>
<p>VT_GROUPS_SPEC</p>
<p>Name of function grouping file.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_JAVA_FILTER_SPEC</p>
<p>Name of Java specific filter file.</p>
<ul class="simple">
<li></li>
</ul>
<p>VT_GROUP_CLASSES</p>
<p>Create a group for each Java class automatically?</p>
<p>yes</p>
<p>VT_MAX_STACK_DEPTH</p>
<p>Maximum number of stack level to be traced. (0 = unlimited)</p>
<p>0</p>
<p>Demangle, Symbol List</p>
<p>VT_GNU_DEMANGLE</p>
<p>Decode (demangle) low-level symbol names into user-level names?</p>
<p>no</p>
<p>VT_GNU_GETSRC</p>
<p>Retrieve the source code line of functions instrumented automatically
with the GNU interface?</p>
<p>yes</p>
<p>VT_GNU_NMFILE</p>
<p>Name of file with symbol list information.</p>
<ul class="simple">
<li></li>
</ul>
<p>When you use these environment variables, make sure that they have the
same value for all processes of your application on all nodes of your
cluster. Some cluster environments do not automatically transfer your
environment when executing parts of your job on remote nodes of the
cluster, and you may need to explicitly set and export them in batch job
submission scripts.</p>
<p><strong>Influencing Trace Buffer Size</strong></p>
<p>The default values of the environment variables VT_BUFFER_SIZE and
VT_MAX_FLUSHES limit the internal buffer of VampirTrace to 32 MB per
process, and the number of times that the buffer is flushed to 1,
respectively. Events that are to be recorded after the limit has been
reached are no longer written into the trace file. The environment
variables apply to every process of a parallel application, meaning that
applications with n processes will typically create trace files n times
the size of a serial application.</p>
<p>To remove the limit and get a complete trace of an application, set
VT_MAX_FLUSHES to 0. This causes VampirTrace to always write the
buffer to disk when it is full. To change the size of the buffer, use
the environment variable VT_BUFFER_SIZE. The optimal value for this
variable depends on the application which is to be traced. Setting a
small value will increase the memory available to the application, but
will trigger frequent buffer flushes by VampirTrace. These buffer
flushes can significantly change the behavior of the application. On the
other hand, setting a large value, like 2G, will minimize buffer flushes
by VampirTrace, but decrease the memory available to the application. If
not enough memory is available to hold the VampirTrace buffer and the
application data, parts of the application may be swapped to disk,
leading to a significant change in the behavior of the application.</p>
<p>Note that you can decrease the size of trace files significantly by
using the runtime function filtering.</p>
<p><strong>Profiling an Application</strong></p>
<p>Profiling an application collects aggregated information about certain
events during a program run, whereas tracing records information about
individual events. Profiling can therefore be used to get a summary of
the program activity and to detect events that are called very often.
The profiling information can also be used to generate filter rules to
reduce the trace file size.</p>
<p>To profile an application, set the variable VT_MODE to STAT. Setting
VT_MODE to STAT:TRACE tells VampirTrace to perform tracing and
profiling at the same time. By setting the variable VT STAT PROPS, the
user can influence whether functions, messages, and/or collective
operations shall be profiled.</p>
<p><strong>Unification of Local Traces</strong></p>
<p>After a run of an instrumented application, the traces of the single
processes need to be unified in terms of timestamps and event IDs. In
most cases, this happens automatically. If the environment variable
VT_UNIFY is set to no, and in the case of certain other circumstances,
it will be necessary to perform unification of local traces manually. To
do this, use the following command:</p>
<p>vtunify &lt;nproc&gt; &lt;prefix&gt;</p>
<p>If VampirTrace was built with support for OpenMP and/or MPI, it is
possible to speedup the unification of local traces significantly. To
distribute the unificationon multible processes, the MPI parallel
version vtunify-mpi can be used as follows:</p>
<p>mpirun -np &lt;nranks&gt; vtunify-mpi &lt;nproc&gt; &lt;prefix&gt;</p>
<p>Furthermore, both tools vtunify and vtunify-mpi are capable of opening
additional OpenMP threads for unification. The number of threads can be
specified by the OMP_NUM_THREADS environment variable.</p>
<p><strong>Synchronized Buffer Flush</strong></p>
<p>When tracing an application, VampirTrace temporarily stores the recorded
events in a trace buffer. Typically, if a buffer of a process or thread
has reached its maximum fill level, the buffer has to be flushed and
other processes or threads may have to wait for this process or thread.
This will result in an asynchronous runtime behavior.</p>
<p>To avoid this problem, VampirTrace provides a buffer flush in a
synchronized manner. This means that if one buffer has reached its
minimum buffer fill level VT_SYNC_FLUSH_LEVEL, all buffers will be
flushed. This buffer flush is only available at appropriate points in
the program flow. Currently, VampirTrace makes use of all MPI collective
functions associated with MPI_COMM_WORLD. Use the environment variable
VT_SYNC_FLUSH to enable synchronized buffer flush.</p>
<p><strong>Enhanced Timer Synchronization</strong></p>
<p>Especially on cluster environments, where each process has its own local
timer, tracing relies on precisely synchronized timers. Therefore,
VampirTrace provides several mechanisms for timer synchronization. The
default synchronization scheme is a linear synchronization at the very
beginning and very end of a trace run with a master-slave communication
pattern.</p>
<p>However, this way of synchronization can become too imprecise for long
trace runs. Therefore, we recommend the usage of the enhanced timer
synchronization scheme of VampirTrace. This scheme inserts additional
synchronization phases at appropriate points in the program flow.
Currently, VampirTrace makes use of all MPI collective functions
associated with MPI_COMM_WORLD.</p>
<p>To enable this synchronization scheme, a LAPACK library with C wrapper
support has to be provided for VampirTrace, and the environment variable
VT_ETIMESYNC has to be set before the tracing. The length of the
interval between two successive synchronization phases can be adjusted
with VT_ETIMESYNC_INTV. The following LAPACK libraries provide a
C-LAPACK API that can be used by VampirTrace for the enhanced timer
synchronization:</p>
<ul class="simple">
<li>CLAPACK</li>
<li>AMD ACML</li>
<li>IBM ESSL</li>
<li>Intel MKL</li>
<li>SUN Performance Library</li>
</ul>
<p><strong>Note:</strong> Systems equipped with a global timer do not need timer
synchronization.</p>
<p><strong>Note:</strong> It is recommended to combine enhanced timer synchronization
and synchronized buffer flush.</p>
<p><strong>Note:</strong> Be aware that the asynchronous behavior of the application
will be disturbed since VampirTrace makes use of asynchronous MPI
collective functions for timer synchronization and synchronized buffer
flush. Only make use of these approaches if your application does not
rely on an asynchronous behavior! Otherwise, keep this fact in mind
during the process of performance analysis.</p>
<p><strong>Recording Additional Events and Counters</strong></p>
<p><strong>Hardware Performance Counters</strong></p>
<p>If VampirTrace has been built with hardware counter support, it is
capable of recording hardware counter information as part of the event
records. To request the measurement of certain counters, the user is
required to set the environment variable VT_METRICS. The variable
should contain a colon-separated list of counter names or a predefined
platform-specific group.</p>
<p>The user can leave the environment variable unset to indicate that no
counters are requested. If any of the requested counters are not
recognized or the full list of counters cannot be recorded due to
hardware resource limits, program execution will be aborted with an
error message.</p>
<p><strong>PAPI Hardware Performance Counters</strong></p>
<p>If the PAPI library is used to access hardware performance counters,
metric names can be any PAPI preset names or PAPI native counter names.
For example, set</p>
<p>VT_METRICS=PAPI_FP_OPS:PAPI_L2_TCM</p>
<p>to record the number of floating point instructions and level 2 cache
misses.</p>
<p><strong>Resource Usage Counters</strong></p>
<p>The Unix system call getrusage provides information about consumed
resources and operating system events of processes such as user/system
time, received signals, and context switches.</p>
<p>If VampirTrace has been built with resource usage support, it is able to
record this information as performance counters to the trace. You can
enable tracing of specific resource counters by setting the environment
variable VT_RUSAGE to a colon-separated list of counter names. For
example, set</p>
<p>VT_RUSAGE=ru_stime:ru_majflt</p>
<p>to record the system time consumed by each process and the number of
page faults. Alternatively, one can set this variable to the value all
to enable recording of all 16 resource usage counters. Note that not all
counters are supported by all Unix operating systems. Linux 2.6 kernels,
for example, support only resource information for six of them.</p>
<p>The resource usage counters are not recorded at every event. They are
only read if 100 ms have passed since the last sampling. The interval
can be changed by setting VT_RUSAGE_INTV to the number of desired
milliseconds. Setting VT_RUSAGE_INTV to zero leads to sampling
resource usage counters at every event, which may introduce a large
runtime overhead. Note that in most cases the operating system does not
update the resource usage information at the same high frequency as the
hardware performance counters. Setting VT_RUSAGE_INTV to a value less
than 10 ms does not usually improve the granularity.</p>
<p>Be aware that, when using the resource usage counters for multi-threaded
programs, the information displayed is valid for the whole process and
not for each single thread.</p>
<p><strong>Memory Allocation Counter</strong></p>
<p>The GNU LIBC implementation provides a special hook mechanism that
allows intercepting all calls to memory allocation and free functions
(e.g. malloc, realloc, free). This is independent from compilation or
source code access, but relies on the underlying system library.</p>
<p>If VampirTrace has been built with memory-tracing support, VampirTrace
is capable of recording memory allocation information as part of the
event records. To request the measurement of the application’s allocated
memory, the user must set the environment variable VT_MEMTRACE to yes.</p>
<p><strong>Note:</strong> This approach to get memory allocation information requires
changing internal function pointers in a non-thread-safe way, so
VampirTrace currently does not support memory tracing for threadable
programs, e.g., programs parallelized with OpenMP or Pthreads!</p>
<p><strong>Pthread API Calls</strong></p>
<p>When tracing applications with Pthreads, only user events and functions
are recorded which are automatically or manually instrumented. Pthread
API functions will not be traced by default. To enable tracing of all
C-Pthread API functions, include the header <em>vt user.h</em> and compile the
instrumented sources with -DVTRACE PTHREAD.</p>
<p>C/C++</p>
<p>#include &#8220;vt_user.h&#8221;</p>
<p>vtcc <strong>-DVTRACE_PTHREAD</strong> hello.c -o hello</p>
<p><strong>I/O Calls</strong></p>
<p>Calls to functions which reside in external libraries can be intercepted
by implementing identical functions and linking them before the external
library. Such &#8220;wrapper functions&#8221; can record the parameters and return
values of the library functions.</p>
<p>If VampirTrace has been built with I/O tracing support, it uses this
technique for recording calls to I/O functions of the standard C
library, which are executed by the application. The following functions
are intercepted by VampirTrace:</p>
<p>close</p>
<p>creat</p>
<p>creat64</p>
<p>dup</p>
<p>dup2</p>
<p>fclose</p>
<p>fcntl</p>
<p>fdopen</p>
<p>fgetc</p>
<p>fgets</p>
<p>flockfile</p>
<p>fopen</p>
<p>fopen64</p>
<p>fprintf</p>
<p>fputc</p>
<p>fputs</p>
<p>fread</p>
<p>fscanf</p>
<p>fseek</p>
<p>fseeko</p>
<p>fseeko64</p>
<p>fsetpos</p>
<p>fsetpos64</p>
<p>ftrylockfile</p>
<p>funlockfile</p>
<p>fwrite</p>
<p>getc</p>
<p>gets</p>
<p>lockf</p>
<p>lseek</p>
<p>lseek64</p>
<p>open</p>
<p>open64</p>
<p>pread</p>
<p>pread64</p>
<p>putc</p>
<p>puts</p>
<p>pwrite</p>
<p>pwrite64</p>
<p>read</p>
<p>readv</p>
<p>rewind</p>
<p>unlink</p>
<p>write</p>
<p>writev</p>
<p>The gathered information will be saved as I/O event records in the trace
file. This feature has to be activated for each tracing run by setting
the environment variable VT_IOTRACE to yes.</p>
<p>This works for both dynamically and statically linked executables. Note
that when linking statically, a warning like the following may be
issued: Using &#8220;dlopen&#8221; in statically linked applications requires at
runtime the shared libraries from the glibc version used for linking.
This is ok as long as the mentioned libraries are available for running
the application.</p>
<p>If you’d like to experiment with some other I/O library, set the
environment variable VT_IOLIB_PATHNAME to the alternative one. Beware
that this library must provide all I/O functions mentioned above;
otherwise VampirTrace will abort.</p>
<p><strong>fork/system/exec Calls</strong></p>
<p>If VampirTrace has been built with LIBC trace support, it is capable of
tracing programs which call functions from the LIBC exec family (execl,
execlp, execle, execv, execvp, execve), system, and fork. VampirTrace
records the call of the LIBC function to the trace. This feature works
for sequential (i.e., no MPI or threaded parallelization) programs only.
It works for both dynamically and statically linked executables. Note
that when linking statically, a warning like the following may be
issued: Using &#8220;dlopen&#8221; in statically linked applications requires at
runtime the shared libraries from the glibc version used for linking.
This is ok as long as the mentioned libraries are available for running
the application.</p>
<p>When VampirTrace detects a call of an exec function, the current trace
file is closed before executing the new program. If the executed program
is also instrumented with VampirTrace, it will create a different trace
file. Note that VampirTrace aborts if the exec function returns
unsuccessfully. Calling fork in an instrumented program creates an
additional process in the same trace file.</p>
<p><strong>MPI Correctness Checking Using UniMCI</strong></p>
<p>VampirTrace supports the recording of MPI correctness events, e.g.,
usage of invalid MPI requests. This is implemented by using the
Universal MPI Correctness Interface (UniMCI), which provides an
interface between tools like VampirTrace and existing runtime MPI
correctness checking tools. Correctness events are stored as markers in
the trace file and are visualized by Vampir. If VampirTrace is built
with UniMCI support, the user only has to enable MPI correctness
checking. This is done by merely setting the environment variable
VT_MPICHECK to yes. Further, if your application crashes due to an MPI
error you should set VT_MPICHECK_ERREXIT to yes. This environmental
variable forces VampirTrace to write its trace to disk and exit
afterwards. As a result, the trace with the detected error is stored
before the application might crash.</p>
<p>To install VampirTrace with correctness checking support, it is
necessary to have UniMCI installed on your system. UniMCI in turn
requires you to have a supported MPI correctness checking tool installed
(currently only the tool Marmot is known to have UniMCI support). So,
all in all, you should use the following order to install with
correctness checking support:</p>
<ol class="arabic simple">
<li>Marmot</li>
</ol>
<p><a class="reference external" href="http://www.hlrs.de/organization/av/amt/research/marmot">http://www.hlrs.de/organization/av/amt/research/marmot</a></p>
<ol class="arabic simple">
<li>UniMCI</li>
</ol>
<p><a class="reference external" href="http://www.tu-dresden.de/zih/unimci">http://www.tu-dresden.de/zih/unimci</a></p>
<ol class="arabic simple">
<li>VampirTrace</li>
</ol>
<p><a class="reference external" href="http://www.tu-dresden.de/zih/vampirtrace">http://www.tu-dresden.de/zih/vampirtrace</a></p>
<p>Information on how to install Marmot and UniMCI is given in their
respective manuals. VampirTrace will automatically detect an UniMCI
installation if the unimci-config tool is in path.</p>
<p><strong>User-defined Counters</strong></p>
<p>In addition to the manual instrumentation, the VampirTrace API provides
instrumentation calls which allow recording of program variable values
(e.g., iteration counts, calculation results, ...) or any other
numerical quantity. A user-defined counter is identified by its name,
the counter group it belongs to, the type of its value (integer or
floating-point) and the unit that the value is quoted (e.g.
&#8220;GFlop/sec&#8221;). The VT_COUNT_GROUP_DEF and VT_COUNT_DEF
instrumentation calls can be used to define counter groups and counters:</p>
<p>Fortran</p>
<p>#include &#8220;vt_user.inc&#8221;</p>
<p>integer&nbsp;:: id, gid</p>
<p>VT_COUNT_GROUP_DEF(’name’, gid)</p>
<p>VT_COUNT_DEF(’name’, ’unit’, type, gid, id)</p>
<p>C/C++</p>
<p>#include &#8220;vt_user.h&#8221;</p>
<p>unsigned int id, gid;</p>
<p>gid = VT_COUNT_GROUP_DEF(&#8220;name&#8221;);</p>
<p>id = VT_COUNT_DEF(&#8220;name&#8221;, &#8220;unit&#8221;, type, gid);</p>
<p>The definition of a counter group is optional. If no special counter
group is desired, the default group &#8220;User&#8221; can be used. In this case,
set the parameter gid of VT_COUNT_DEF() to VT_COUNT_DEFGROUP. The
third parameter type of VT_COUNT_DEF specifies the data type of the
counter value. To record a value for any of the defined counters, the
corresponding instrumentation call VT_COUNT * VAL must be invoked.</p>
<p><strong>Fortran:</strong></p>
<p><strong>Type</strong></p>
<p>Count call</p>
<p>Data type</p>
<p>VT_COUNT_TYPE_INTEGER</p>
<p>VT_COUNT_INTEGER_VAL</p>
<p>integer (4 byte)</p>
<p>VT_COUNT_TYPE_INTEGER8</p>
<p>VT_COUNT_INTEGER8_VAL</p>
<p>integer (8 byte)</p>
<p>VT_COUNT_TYPE_REAL</p>
<p>VT_COUNT_REAL_VAL</p>
<p>real</p>
<p>VT_COUNT_TYPE_DOUBLE</p>
<p>VT_COUNT_DOUBLE_VAL</p>
<p>double precision</p>
<p><strong>C/C++:</strong></p>
<p><strong>Type</strong></p>
<p>Count call</p>
<p>Data type</p>
<p>VT_COUNT_TYPE_SIGNED</p>
<p>VT_COUNT_SIGNED_VAL</p>
<p>signed int (max. 64-bit)</p>
<p>VT_COUNT_TYPE_UNSIGNED</p>
<p>VT_COUNT_UNSIGNED_VAL</p>
<p>unsigned int (max. 64-bit)</p>
<p>VT_COUNT_TYPE_FLOAT</p>
<p>VT_COUNT_FLOAT_VAL</p>
<p>float</p>
<p>VT_COUNT_TYPE_DOUBLE</p>
<p>VT_COUNT_DOUBLE_VAL</p>
<p>double</p>
<p>The following example records the loop index i:</p>
<p>Fortran</p>
<p>#include &#8220;vt_user.inc&#8221;</p>
<p>program main</p>
<p>integer&nbsp;:: i, cid, cgid</p>
<p>VT_COUNT_GROUP_DEF(’loopindex’, cgid)</p>
<p>VT_COUNT_DEF(’i’, ’#’, VT_COUNT_TYPE_INTEGER, cgid, cid)</p>
<p>do i=1,100</p>
<p>&nbsp;&nbsp;&nbsp; VT_COUNT_INTEGER_VAL(cid, i)</p>
<p>end do</p>
<p>end program main</p>
<p>C/C++</p>
<p>#include &#8220;vt_user.h&#8221;</p>
<p>int main() {</p>
<p>&nbsp;&nbsp; unsigned int i, cid, cgid;</p>
<p>&nbsp;&nbsp; cgid = VT_COUNT_GROUP_DEF(’loopindex’);</p>
<p>&nbsp;&nbsp; cid = VT_COUNT_DEF(&#8220;i&#8221;, &#8220;#&#8221;, VT_COUNT_TYPE_UNSIGNED, cgid);</p>
<p>&nbsp;&nbsp; for( i = 1; i &lt;= 100; i++ ) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VT_COUNT_UNSIGNED_VAL(cid, i);</p>
<p>&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp; return 0;</p>
<p>}</p>
<p>For all three languages, the instrumented sources have to be compiled
with -DVTRACE. Otherwise, the VT * calls are ignored. Optionally, if
the sources contain further VampirTrace API calls and only the calls for
user-defined counters will be disabled, then the sources have to be
compiled with -DVTRACE_NO_COUNT in addition to -DVTRACE .</p>
<p><strong>User-Defined Markers</strong></p>
<p>In addition to the manual instrumentation, the VampirTrace API provides
instrumentation calls which allow recording of special user information,
which can be used to better identify parts of interest. A user-defined
marker is identified by its name and type.</p>
<p>Fortran</p>
<p>#include &#8220;vt_user.inc&#8221;</p>
<p>integer&nbsp;:: mid</p>
<p>VT_MARKER_DEF(’name’, type, mid)</p>
<p>VT_MARKER(mid, ’text’)</p>
<p>C/C++</p>
<p>#include &#8220;vt_user.h&#8221;</p>
<p>unsigned int mid;</p>
<p>mid = VT_MARKER_DEF(&#8220;name&#8221;,type);</p>
<p>VT_MARKER(mid, &#8220;text&#8221;);</p>
<p>Types for Fortran/C/C++</p>
<p>VT_MARKER_TYPE_ERROR</p>
<p>VT_MARKER_TYPE_WARNING</p>
<p>VT_MARKER_TYPE_HINT</p>
<p>For all three languages, the instrumented sources have to be compiled
with -DVTRACE. Otherwise, the VT * calls are ignored. Optionally, if
the sources contain further VampirTrace API calls and only the calls for
user-defined markers will be disabled, then the sources have to be
compiled with -DVTRACE_NO_MARKER in addition to -DVTRACE .</p>
<p><strong>Filtering and Grouping</strong></p>
<p>By default, all calls of instrumented functions will be traced;
consequently, the resulting trace files can easily become very large. In
order to decrease the size of a trace, VampirTrace allows the
specification of filter directives before running an instrumented
application. The user can decide on how often an instrumented
function/region should be recorded to a trace file. To use a filter, the
environment variable VT_FILTER_SPEC needs to be defined. It should
contain the path and name of a file with filter directives. Following is
an example of a file containing filter directives:</p>
<p>#VampirTrace region filter specification</p>
<p>#</p>
<p>#call limit definitions and region assignments</p>
<p>#</p>
<p>#syntax: &lt;regions&gt; &#8211; &lt;limit&gt;</p>
<p>#</p>
<p>#regions&nbsp; semicolon-separated list of regions</p>
<p>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (can be wildcards)</p>
<p>#limit&nbsp;&nbsp;&nbsp; assigned call limit</p>
<p>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 = region(s) denied</p>
<p>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1 = unlimited</p>
<p>#</p>
<p>add;sub;mul;div &#8211; 1000</p>
<p>* &#8211; 3000000</p>
<p>These region filter directives allow the functions add, sub, mul and div
to be recorded at most 1000 times. The remaining functions * will be
recorded at most 3,000,000 times.</p>
<p>Besides creating filter files manually, you can also use the vtfilter
tool to generate them automatically. This tool reads a provided trace
and decides whether a function should be filtered or not, based on the
evaluation of certain parameters.</p>
<p><strong>Rank Specific Filtering</strong></p>
<p>An experimental extension allows rank specific filtering. Use &#64; clauses
to restrict all following filters to the given ranks. The rank selection
must be given as a list of &lt;from&gt; - &lt;to&gt; pairs or single values.</p>
<p>&#64; 4 - 10, 20 - 29, 34</p>
<p>foo;bar &#8211; 2000</p>
<p>* &#8211; 0</p>
<p>The example defines two limits for the ranks 4 - 10, 20 - 29, and 34.</p>
<p><strong>Attention:</strong> The rank specific rules are activated later than usual at
MPI Init, because the ranks are not available earlier. The special MPI
routines MPI Init, MPI Init thread, and MPI Initialized cannot be
filtered in this way.</p>
<p><strong>Function Grouping</strong></p>
<p>VampirTrace allows assigning functions/regions to a group. Groups can,
for instance, be highlighted by different colors in Vampir displays. The
following standard groups are created by VampirTrace:</p>
<p><strong>Group name</strong></p>
<p><strong>Contained functions/regions</strong></p>
<p>MPI</p>
<p>MPI functions</p>
<p>OMP</p>
<p>OpenMP API function calls</p>
<p>OMP_SYNC</p>
<p>OpenMP barriers</p>
<p>OMP_PREG</p>
<p>OpenMP parallel regions</p>
<p>Pthreads</p>
<p>Pthread API function calls</p>
<p>MEM</p>
<p>Memory allocation functions (⇒ Section&nbsp;[#mem_alloc_counter [*]])</p>
<p>I/O</p>
<p>I/O functions (⇒ Section&nbsp;[#io_calls [*]])</p>
<p>LIBC</p>
<p>LIBC fork/system/exec functions (⇒ Section&nbsp;[#execfork [*]])</p>
<p>Application</p>
<p>remaining instrumented functions and source code regions</p>
<p>Additionally, you can create your own groups, if, for example, you wish
to better distinguish different phases of an application. To use
function/region grouping, set the environment variable VT_GROUPS_SPEC
to the path of a file which contains the group assignments. Below is an
example of how to use group assignments:</p>
<p># VampirTrace region groups specification</p>
<p>#</p>
<p># group definitions and region assignments</p>
<p>#</p>
<p># syntax: &lt;group&gt;=&lt;regions&gt;</p>
<p>#</p>
<p># group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; group name</p>
<p># regions&nbsp;&nbsp;&nbsp;&nbsp; semicolon-separated list of regions</p>
<p>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (can be wildcards)</p>
<p>#</p>
<p>CALC=add;sub;mul;div</p>
<p>USER=app_*</p>
<p>These group assignments associate the functions add, sub, mul and div
with group &#8220;CALC&#8221;, and all functions with the prefix app are associated
with group &#8220;USER&#8221;.</p>
</div>


</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>